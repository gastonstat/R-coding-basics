[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R Coding Basics",
    "section": "",
    "text": "About\nThis text seeks to give you an introduction to programming in R.\nIn a nutshell, I discuss the basics of R, covering properties of data objects, such as vectors, factors, matrices, lists, and data frames. Likewise, I describe fundamental notions of programming (e.g. functions, conditionals, iterations).\n\nAbout You\nI am assuming that you have both R or RStudio installed in your computer. If this is not the case, you can take a look at Breaking the Ice with R\nhttps://www.gastonsanchez.com/R-ice-breaker\n\n\nCitation\nYou can cite this work as:\nSanchez, G. (2022) An Introduction to the Basics of Coding in R.  https://www.gastonsanchez.com/R-coding-basics\n\n\n\nMy Series of R Tutorials\nThis document is part of a series of texts that I’ve written about Programming and Data Analysis in R:\n\nBreaking the Ice with R: Getting Started with R and RStudio  https://www.gastonsanchez.com/R-ice-breaker\nTidy Hurricanes: Analyzing Tropical Storms with Tidyverse Tools  https://www.gastonsanchez.com/R-tidy-hurricanes\nR Coding Basics: An Introduction to the Basics of Coding in R  https://www.gastonsanchez.com/R-coding-basics\nRolling Dice: Exploring Simulations in Games of Chance with R  https://www.gastonsanchez.com/R-rolling-dice\nR for Strings: Handling Strings with R  https://www.gastonsanchez.com/R-for-strings\nWeb Technologies in R: A Short Introduction to Web Technologies in R  https://www.gastonsanchez.com/R-web-technologies\n\n\n\n\nDonation\nAs a Data Science and Statistics educator, I love to share the work I do. Each month I spend dozens of hours curating learning materials like this resource. If you find any value and usefulness in it, please consider making a one-time donation—via paypal—in any amount (e.g. the amount you would spend inviting me a cup of coffee or any other drink). Your support really matters.\n\n\n\nLicense\nThis work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License."
  },
  {
    "objectID": "1-01-vectors-intro.html",
    "href": "1-01-vectors-intro.html",
    "title": "1  First Contact with Vectors",
    "section": "",
    "text": "In order to enjoy and exploit R as a computational tool, one of the first things you need to learn is the various ways R handles data. The formal name for these programming elements is data objects also known as data structures. They form the ecosystem of data containers that we can use to handle various types of data sets, and be able to operate with them in different forms.\nI’m going to use financial math examples as an excuse to introduce and explain the material. I’ve found that having a common theme helps avoiding falling into the “teaching trap” of presenting isolated examples in a vacuum."
  },
  {
    "objectID": "1-01-vectors-intro.html#motivation-compound-interest",
    "href": "1-01-vectors-intro.html#motivation-compound-interest",
    "title": "1  First Contact with Vectors",
    "section": "1.1 Motivation: Compound Interest",
    "text": "1.1 Motivation: Compound Interest\nI would like to ask you if you have any of the following accounts:\n\nSavings account?\nRetirement account?\nBrokerage account?\n\nDon’t worry if you don’t have any of these accounts. I certainly didn’t have any of those accounts until I started my first job right after I finished college.\nAnyway, let’s consider a hypothetical scenario in which you have $1000, and you decide to deposit them in a savings account that pays you an annual interest rate of 2%. Assuming that you leave that money in the savings account, an important question to ask is:\n\nHow much money will you have in your savings account one year from now?\n\nThe answer to this question is given by the compound interest formula:\n\\[\n\\text{deposit} + \\text{annual paid interest} = \\text{amount in one year}\n\\]\nIn this example, you deposit $1000, and the bank pays you 2% of $1000 = $20, 12 months from now.\nIn mathematical terms, we can write the following equation to calculate the amount that you should expect to have in your savings account within a year:\n\\[\n1000 + 1000 (0.02) = 1000 \\times (1 + 0.02) = 1020\n\\]\nYou can confirm this by running the following R command:\n\n# in one year\n1000 * (1.02)\n\n[1] 1020\n\n\nNow, if you leave the $1020 in the savings account for one more year, assuming that the bank keeps paying you a 2% annual return, how much money will you have at the end of the second year?\nWell, all you have to do is repeat the same computation, this time by letting the $1020—accumulated during the first year—compound for one more year:\n\\[\n1020 + 1020 (0.02) = 1020 \\times (1 + 0.02) = 1040.40\n\\]\nwhich in R can be computed as:\n\n# in two years\n1020 * (1.02)\n\n[1] 1040.4\n\n\nHow much money will you have at the end of three years? Again, take the amount saved at the end of year 2, and compund it for one more year:\n\\[\n1040.4 + 1040.4 (0.02) = 1040 \\times (1 + 0.02) = 1061.208\n\\]\nWe can confirm this in R by running the following command:\n\n# in three years\n1040.40 * (1.02)\n\n[1] 1061.208\n\n\n\n1.1.1 Comments\nOne thing to note in all the previous commands is the use of the informative text preceded by the pound or hash # symbol, for example: # in three years. This kind of text is not a command but rather a comment.\n\n# this is a comment\n# and so is this\n\n# in four years\n1061.208 * (1.02)\n\n[1] 1082.432\n\n\nAll programming languages use a set of characters to indicate that a specific part or lines of code are comments, that is, things that are not to be executed. R uses the # symbol to specify comments. Any code to the right of # will not be executed by R.\n\n\n1.1.2 Creating Objects\nOften, it will be more convenient to create objects , also referred to as variables, that store both input and output values. To do this, type the name of the object, followed by the equals sign =, followed by the assigned value. For example, you can create an object d for the initial deposit of $1000, and then inspect the object by typing its name:\n\n# deposit 1000\nd = 1000\nd\n\n[1] 1000\n\n\nAlternatively, you can also use the arrow operator <-, technically known as the assignment operator in R. This operator consists of the left-angle bracket (i.e. the less-than symbol) and the dash (i.e. hyphen character).\n\n# interest rate of 2%\nr <- 0.02\nr\n\n[1] 0.02\n\n\n\n\n1.1.3 Assignment Statements\nAll R statements where you create objects are known as “assignments”, and they have this form:\nobject <- value\n\n# equivalent to\nobject = value\nthis means you assign a value to a given object; you can read the previous assignment when we created the interest rate as “r gets 0.02”.\nHere are more assignments for each of the savings amounts at the end of years 1, 2, and 3:\n\n# amounts at the end of years 1, 2, and 3\na1 = d * (1 + r)\na2 = a1 * (1 + r)\na3 = a2 * (1 + r)\na3\n\n[1] 1061.208\n\n\n\n\n1.1.4 Case Sensitive\nRecall that R is case sensitive. This means that a1 is not the same as A1. Similarly, money is not the same as Money or MONEY\n\n# case sensitive\nmoney = 10\nMoney = 100\nMONEY = 1000\n\nmoney + Money\n\n[1] 110\n\n\n\nMONEY - Money\n\n[1] 900\n\n\n\n\n1.1.5 Use Descriptive Names\nWhile the names of objects such as d, r, a1, etc, are good for a computer, they can be a bit cryptic for a human being. Right now you may not have an issue understanding what those names refer to. You may even find these names to be quite convenient: they are short and easy to type. Moreover, they match the algebraic notation used in the compound interest formula. What’s not to like about them?\nWell, the issue is that this kind of names are too short. Mathematically there’s nothing wrong with them. Computationally, from the point of view of the programming language (R), there is also nothing inherently bad about them. However, from the human (i.e. the reader or the code reviewer) standpoint, it is much better if we use more descriptive names, for example:\n\ndeposit instead of d\nrate instead of r\namount1 instead of a1\n\nThe longer and more descriptive names are good for a computer and also for a human being (that reads English).\n\n# inputs\ndeposit = 1000\nrate = 0.02\n\n# amounts at the end of years 1, 2, and 3\namount1 = deposit * (1 + rate)\namount2 = amount1 * (1 + rate)\namount3 = amount2 * (1 + rate)\namount3\n\n[1] 1061.208\n\n\nThe idea of using descriptive names has to do with a broader topic known as literate programming. This term, coined by computer scientist Donald Knuth, involves the core idea of creating programs as being works of literature. As Donald puts it:\n\n“Let us change our traditional attitude to the construction of programs: Instead of imagining that our main task is to instruct a computer what to do, let us concentrate rather on explaining to human beings what we want a computer to do.”\nDonald Knuth (1984)\n\nWhenever possible, make an effort to use descriptive names. While they don’t matter that much for the computer, they definitely can have a big impact on any person that takes a look at the code, which most of the times it’s going to be your future self. As it turns out, we tend to spend more time reviewing and reading code than writing it. So do yourself (and others) a favor by using descriptive names for your objects.\n\n\n1.1.6 Combining various objects into a single one\nWe can store various computed values in a single object using the combine or catenate function c(). Simply list two or more objects inside this function, separating them by a comma ,. Here’s an example for how to use c() to define an object amounts containing the amounts at the end of years 1, 2, and 3.\n\n# inputs\ndeposit = 1000\nrate = 0.02\n\n# amounts at the end of years 1, 2, and 3\namount1 = deposit * (1 + rate)\namount2 = amount1 * (1 + rate)\namount3 = amount2 * (1 + rate)\n\n# combine (catenate) in a single object\namounts = c(amount1, amount2, amount3)\namounts\n\n[1] 1020.000 1040.400 1061.208\n\n\nSo far we have created a bunch of objects. You can use the list function ls() to display the names of the available objects. But what kind of objects are we dealing with?\nIt turns out that all the objects we have so far are vectors. You’ll learn about the basic properties of vectors in the next chapter."
  },
  {
    "objectID": "1-01-vectors-intro.html#exercises",
    "href": "1-01-vectors-intro.html#exercises",
    "title": "1  First Contact with Vectors",
    "section": "1.2 Exercises",
    "text": "1.2 Exercises\n1) Area of a rectangle.\nAs you know, the area of a rectangle is the product of its length and width:\n\\[\n\\text{area of rectangle} = \\text{length} \\times \\text{width}\n\\]\nWrite R code to compute the area of a rectangle of a certain length and a certain width. You can give length and width numeric values of your preference. The computed area should be stored in an object area.\n\n\nShow answer\nlength = 3\nwidth = 4\n\narea_rect = length * width\n\n\n\n2) Area of a circle.\nAs you know, the area of a circle of radius \\(r\\) is given by\n\\[\n\\text{area of circle} = \\pi \\times r^2\n\\]\nWrite R code to compute the area of a circle of radius \\(r = 5\\). Write code in a way that you create a radius object, and an area object. By the way, R comes with a built-in constant pi for the number \\(\\pi\\).\n\n\nShow answer\nradius = 5\n\narea_circ = pi * radius^2\n\n\n\n3) In this chapter we introduced the formula of Future Value. There is also the Present Value which is the current value of a future sum of money or stream of cash flows given a specified rate of return. Its equation is given by:\n\\[\n\\text{PV} = \\text{FV} \\times \\frac{1}{(1 + r)^n}\n\\]\nwhere:\n\n\\(\\text{FV}\\) = Future Value\n\\(r\\) = Rate of return\n\\(n\\) = Number of periods\n\nWrite R code to compute the Present Value of $2,200 one year from now, knowing that the annual rate of return is \\(r=3\\%\\). Try using descriptive names for the objects created to obtain the present value.\n\n\nShow answer\nFV = 2200\nrate = 0.03\nyears = 1\n\nPV = FV / ((1 + rate)^years)\n\n\n\n4) Consider the monthly bills of an undergraduate student:\n\ncell phone $90\ntransportation $30\ngroceries $580\ngym $15\nrent $1700\nother $85\n\n\nUse assignments to create variables phone, transportation, groceries, gym, rent, and other with their corresponding amounts.\n\n\n\nShow answer\ncellphone = 90\ntransportation = 30\ngroceries = 580\ngym = 15\nrent = 1700\nother = 85\n\n\n\nCreate a total object with the sum of the expenses.\n\n\n\nShow answer\ntotal = cellphone + transportation + groceries + gym + rent + other\n\n\n\nAssuming that the student has the same expenses every month, how much would she spend during a school “term”? (assume the term involves five months).\n\n\n\nShow answer\nsemester_exps = total * 5"
  },
  {
    "objectID": "1-02-vectors-properties.html",
    "href": "1-02-vectors-properties.html",
    "title": "2  Properties of Vectors",
    "section": "",
    "text": "Vectors are the most basic kind of data objects in R. Pretty much all other R data objects are derived (or are built) from vectors. This is the reason why I like to say that, to a large extent, R is a vector-based programming language.\nBased on my own experience, becoming proficient in R requires a solid understanding of the properties and behavior of R vectors."
  },
  {
    "objectID": "1-02-vectors-properties.html#motivation",
    "href": "1-02-vectors-properties.html#motivation",
    "title": "2  Properties of Vectors",
    "section": "2.1 Motivation",
    "text": "2.1 Motivation\nIn the preceding chapter we ended up creating six main objects, which I’m bringing back for you in the following code chunk:\n\n# inputs\ndeposit = 1000\nrate = 0.02\n\n# amounts at the end of years 1, 2, and 3\namount1 = deposit * (1 + rate)\namount2 = amount1 * (1 + rate)\namount3 = amount2 * (1 + rate)\n\n# combine in a single object\namounts = c(amount1, amount2, amount3)\namounts\n\n[1] 1020.000 1040.400 1061.208\n\n\nAs we said, all these objects are vectors.\nTo give you a mental picture of what a vector could like, you can think of a vector as set of contiguous “cells” of data, like in the diagram below:\n\n\n\n\n\nThink of vectors as contiguous cells of data.\n\n\n\n\nBecause this is supposed to be a “mental representation” of a vector, you can think of a vector either horizontally or vertically oriented. It does not really matter which orientation you prefer to visualize since R has no notion of a vector’s orientation.\nRegardless of how you decide to picture a vector in your head, an important trait of this class of object, and of any other data object in R, is that the starting position or index is always number 1."
  },
  {
    "objectID": "1-02-vectors-properties.html#vectors-are-atomic-objects",
    "href": "1-02-vectors-properties.html#vectors-are-atomic-objects",
    "title": "2  Properties of Vectors",
    "section": "2.2 Vectors are Atomic Objects",
    "text": "2.2 Vectors are Atomic Objects\nThe first thing you should learn about R vectors is that they are considered to be atomic structures, which is just the fancy name to indicate that all the elements in a vector are of the same type.\nR has four main basic types of atomic vectors:\n\nlogical\ninteger\ndouble or real\ncharacter\n\nHere are simple examples of the four common data types of vectors:\n\n# logical\na = TRUE\n\n# integer\nx = 1L\n\n# double (real)\ny = 5\n\n# character\nb = \"yosemite\"\n\nLogical values, known as boolean values in other languages, are TRUE and FALSE. These values can be abbreviated by using their first letters T and F, although I discourage you from doing this because it can make code review a bit harder. Also, notice that these logical values are specified with upper case letters. Recall that R is case sensitive, so if you type True or False R will not recognize them as logical values.\nInteger values have an awkward syntax. Notice the appended L when assigning number 1 to object x. This is not a typo. Rather, this is the syntax used in R to indicate that a number (with no decimals) is an integer.\nIf you just simply type a number like 1 or 5, even though cosmetically they correspond to the mathematical notion of integer numbers, R stores those numbers as double type. So if you want to declare those numbers as type integer, you should append an upper case letter L to encode them as 1L and 5L.\nCharacter types, referred to as strings in other languages, are specified by surrounding characters within quotes: either double quotes \"yosemite\" or single quotes 'yosemite'. The important thing is to have an opening and a closing quote of the same kind.\nThe following diagram summarizes the four common data types of vectors.\n\n\n\n\n\nCommon data types of atomic vectors.\n\n\n\n\n\n2.2.1 Complex and Raw Types\nThere are two additional types that are less commonly used: complex (for complex numbers), and raw (raw bytes) which is a binary format used by R.\n\n\n\n\n\nThe 4 most common, and 2 less common, data types of atomic vectors.\n\n\n\n\nI got my first contact with R back in 2001, and I’ve been using it almost on a daily basis since 2005. I have never had the need to use raw vectors; R may be using them in the background but not me (at least not explicitly or consciously). As for complex numbers, I’ve seen them every once in a while when doing certain matrix algebra computations. But again, I haven’t had the need to intentionally work with complex values. I can say the same thing about most of my colleagues: they rarely use these data types. And I’m willing to bet that you will rarely use them too. But now you know, if you ever need to work with complex and/or raw values, they are available in R."
  },
  {
    "objectID": "1-02-vectors-properties.html#types-and-modes",
    "href": "1-02-vectors-properties.html#types-and-modes",
    "title": "2  Properties of Vectors",
    "section": "2.3 Types and Modes",
    "text": "2.3 Types and Modes\nHow do you know that a given vector is of a certain data type? For better or worse, there is a couple of functions that allow you to answer this question:\n\ntypeof()\nstorage.mode()\nmode()\n\nAlthough not commonly used within the R community, my recommended function to determine the data type of a vector is typeof(). The reason for this recommendation is because typeof() returns the data types previously listed which are what most other programming languages use:\n\ntypeof(deposit)\n\n[1] \"double\"\n\ntypeof(rate)\n\n[1] \"double\"\n\n\nYou should know that among the R community, many useRs don’t really talk about types. Instead, because of historical reasons related to the S language—on which R is based—you will often hear useRs talking about modes. To further complicate matters, there is not just one but two functions related to the concept of mode: storage.mode() and mode().\n\nstorage.mode(deposit)\n\n[1] \"double\"\n\nmode(deposit)\n\n[1] \"numeric\"\n\n\nBoth storage.mode() and mode() rely on the output of typeof(), and as their name indicate, provide information about the storage mode. So what is the difference between these functions?\nFor practical purposes, storage.mode() is similar to typeof(), in the sense that they both return the same output:\n\ntypeof(deposit)\n\n[1] \"double\"\n\nstorage.mode(deposit)\n\n[1] \"double\"\n\n\nIn turn, mode() behaves a bit different. mode() groups together types \"double\" and \"integer\" into a single mode called \"numeric\" because both data types are numeric values.\n\ntypeof(deposit)\n\n[1] \"double\"\n\nmode(deposit)\n\n[1] \"numeric\"\n\n\nThe following diagram depicts the numeric mode of types integer and double:\n\n\n\n\n\nData types “integer” and “double” correspond to “numeric” mode.\n\n\n\n\nR also comes with a set of testing functions to determine the type and mode of a given value:\n\nis.logical() to test if a value is of type logical\nis.integer() to test if a value is of type integer\nis.double() to test if a value is of type double\nis.numeric() to test if a value is of numeric mode: either integer or double\nis.character() to test if a value is of type character\n\nWe discuss more details about how R handles data types in chapter More About Vectors. In the meantime, the following table shows basic examples of each common data type, and the output of associated functions that give you information about the type and mode of vectors:\n\n\n\nExample\ntypeof()\nstorage.mode()\nmode()\n\n\n\n\nTRUE\n\"logical\"\n\"logical\"\n\"logical\"\n\n\n1L\n\"integer\"\n\"integer\"\n\"numeric\"\n\n\n1\n\"double\"\n\"double\"\n\"numeric\"\n\n\n\"one\"\n\"character\"\n\"character\"\n\"character\""
  },
  {
    "objectID": "1-02-vectors-properties.html#special-values",
    "href": "1-02-vectors-properties.html#special-values",
    "title": "2  Properties of Vectors",
    "section": "2.4 Special Values",
    "text": "2.4 Special Values\nIn addition to the four common data types, R also comes with a series of special values:\n\nNULL is the null object (it has length zero). The way I like to think of this is as “nothing”; that is, an object that represents “nothing”.\nNA, which stands for Not Available, indicates a missing value. By default, typing NA is stored as a logical value. But there are also special types of missing values.\n\nNA_integer_\nNA_real_\nNA_character_\n\nNaN indicates Not a Number. An example of this value is the output returned by computing the square root of a negative number: sqrt(-5)\nInf indicates positive infinite, e.g. 100/0\n-Inf indicates negative infinite, e.g. -100/0\n\nR also comes with a set of testing functions to determine if a given value is of a special kind:\n\nis.null() to test if a value is NULL\nis.na() to test if a value is NA\nis.nan() to test if a value is NaN\nis.infinite() to test if a value is Inf or -Inf"
  },
  {
    "objectID": "1-02-vectors-properties.html#length-of-vectors",
    "href": "1-02-vectors-properties.html#length-of-vectors",
    "title": "2  Properties of Vectors",
    "section": "2.5 Length of Vectors",
    "text": "2.5 Length of Vectors\nAnother important property about vectors is that they have length, which refers to the number of elements or cells that they contain. If it helps, you can think of length as the “size” of a vector.\nThe simplest kind of vectors are single values—i.e. vectors with just one element. For example, objects such as deposit and rate are one-element vectors. To find the length of a vector you use the function length()\n\nlength(deposit)\n\n[1] 1\n\nlength(amounts)\n\n[1] 3\n\n\nBy the way, vectors can be of any length, including 0. We talk more about these special vectors in the next chapter.\n\nNo Scalars in R\nIn most other languages, a number like 5 or a logical TRUE are usually considered to be “scalars”. R, however, does not have the concept of “scalar”, instead the simplest data structure is that of a one-element vector. This means that when you type 5 R handles this data with a vector of length one."
  },
  {
    "objectID": "1-02-vectors-properties.html#vector-elements-can-have-names",
    "href": "1-02-vectors-properties.html#vector-elements-can-have-names",
    "title": "2  Properties of Vectors",
    "section": "2.6 Vector elements can have names",
    "text": "2.6 Vector elements can have names\nAnother feature of vectors is that their elements can have names. For example, we have the amounts vector that contains the savings amounts at the end of years 1, 2, and 3:\n\namounts\n\n[1] 1020.000 1040.400 1061.208\n\n\nWe can give names to the elements in amounts by using the names() function. We apply names() to amounts and we assign a vector of names like so:\n\nnames(amounts) = c(\"year1\", \"year2\", \"year3\")\namounts\n\n   year1    year2    year3 \n1020.000 1040.400 1061.208"
  },
  {
    "objectID": "1-02-vectors-properties.html#exercises",
    "href": "1-02-vectors-properties.html#exercises",
    "title": "2  Properties of Vectors",
    "section": "2.7 Exercises",
    "text": "2.7 Exercises\nConsider the following three types of financial products:\n\njoint savings account that pays 2% annual return, during 2 years,\njoint money market account that pays 3% annual return, during 3 years\nindividual certificate of deposit that pays 4% annual return, during 4 years\n\nQuestions below.\n\n1) Use the c() function to create a character vector accounts such that when printed it displays the values shown below:\n\n\n[1] \"savings\"      \"money market\" \"certificate\" \n\n\n\n\nShow answer\naccounts = c(\"savings\", \"money market\", \"certificate\")\n\n\n\n2) Use the c() function to create a vector joint of logical values such that when printed it displays the values shown below:\n\n\n[1]  TRUE  TRUE FALSE\n\n\n\n\nShow answer\njoint = c(TRUE, TRUE, FALSE)\n\n\n\n3) Use the c() function to create a vector rates such that when printed it displays the values shown below:\n\n\n[1] 0.02 0.03 0.04\n\n\n\n\nShow answer\nrates = c(0.02, 0.03, 0.04)\n\n\n\n4) Use the function names() to give names to the elements of your vector rates. When printing rates you should get following output:\n\n\nsavings  market  certif \n   0.02    0.03    0.04 \n\n\n\n\nShow answer\nnames(rates) = c('savings', 'market', 'certif')\n\n\n\n5) Use the c() function to create a vector years of integer values such that when printed it displays the values shown below. Recall that integer values are of the form 1L.\n\n\n[1] 2 3 4\n\n\n\n\nShow answer\nyears = c(2L, 3L, 4L)\n\n\n\n6) Use the typeof() function to inspect the data type of accounts, joint, rates, and years. Confirm that their output is \"character\", \"logical\", \"double\" and \"integer\", respectively.\n\n\nShow answer\ntypeof(accounts)\ntypeof(joint)\ntypeof(rates)\ntypeof(years)\n\n\n\n7) Use the length() function to inspect the length of accounts, joint, rates, and years.\n\n\nShow answer\nlength(accounts)\nlength(joint)\nlength(rates)\nlength(years)\n\n\n\n8) Explain, in your own words, why vectors are said to be atomic objects.\n\n9) Explain, in your own words, the difference between the output of functions typeof() and mode()—when applied to vectors."
  },
  {
    "objectID": "1-03-vectors-creation.html",
    "href": "1-03-vectors-creation.html",
    "title": "3  Creating Vectors",
    "section": "",
    "text": "In the preceding chapter you started learning about the basic properties of vectors. We focused on the common flavors of vectors (e.g. logical, integer, double, and character), reviewed special values (e.g. NULL, NA), talked about the length or size of a vector, and we also mentioned that elements in a vector can have names.\nLikewise, you have seen two basic ways to create simple vectors:\nIn this chapter I discuss two broad topics: 1) a review of various functions and ways to create vectors, and 2) a description of the coercion notion. Why should you learn about various forms of vector creation in R? Because as I said, R is—to a large extent—a vector-based language, and you have to be ready to create multiple kinds of vectors, and to take advantage of some of the mechanisms that R provides for doing this. As for the topic of coercion, you also need to understand the behavior of R when working with vectors of different data types."
  },
  {
    "objectID": "1-03-vectors-creation.html#creating-vectors-with-c",
    "href": "1-03-vectors-creation.html#creating-vectors-with-c",
    "title": "3  Creating Vectors",
    "section": "3.1 Creating vectors with c()",
    "text": "3.1 Creating vectors with c()\nWe’ve seen how to create simple vectors containing just one element (i.e.  length-1 vectors)\n\n# inputs\ndeposit = 1000\nrate = 0.02\n\n# amounts at the end of years 1, 2, and 3\namount1 = deposit * (1 + rate)\namount2 = amount1 * (1 + rate)\namount3 = amount2 * (1 + rate)\n\nWe’ve also seen the basic use of the combine function c() to create a vector containing several elements:\n\n# combine amounts in a single vector\namounts = c(amount1, amount2, amount3)\namounts\n\n[1] 1020.000 1040.400 1061.208\n\n\nThe c() function is one of the primary functions to create vectors of length greater than one. Here’s another example for how to create a vector flavors with some ice-cream flavors:\n\nflavors <- c(\"lemon\", \"vanilla\", \"chocolate\")\n\nflavors\n\n[1] \"lemon\"     \"vanilla\"   \"chocolate\"\n\n\nBasically, you call c() and you type in the values, separating them by commas.\nIf your vector has only one element, you don’t need to call the c() function.\n\n# no need to use c() to create a one-element vector\nlemon = c(\"lemon\")\n\n# instead just do this\nlemon = \"lemon\"\n\nOne more thing that you can do when using c() is to give names to the elements of the created vector. This is done by joining pairs of values of the form: 'name' = value, where 'name' is the name given to the value of an element. For instance, you can create the vector amounts and give names to each element like this:\n\n# give names to elements when using c()\n# (names specified with quotes)\namounts = c(\n  \"year1\" = amount1, \n  \"year2\" = amount2, \n  \"year3\" = amount3)\n\namounts\n\n   year1    year2    year3 \n1020.000 1040.400 1061.208 \n\n\nAs you can tell, the names of each element are specified as character values: \"year1\", \"year2\", and \"year3\". Interestingly, you can also specify names without quoting them:\n\n# give names to elements when using c()\n# (names unquoted)\namounts2 = c(\n  year1 = amount1, \n  year2 = amount2, \n  year3 = amount3)\n\namounts2\n\n   year1    year2    year3 \n1020.000 1040.400 1061.208 \n\n\nThis way of giving names to the elements of a vector can feel a bit surprising, especially to users that have previous programming experience but are new to the R syntax. Personally, I don’t really care about having 2 different—and apparently confusing—ways to give names to elements when using functions like c(). Having said that, I can perfectly understand the initial shock and confusion that this may cause to non-experienced useRs.\nTo be consistent with most other languages, and also to play defensively, I tend to recommend quoting the values that are supposed to be the names of the elements in a vector. Again, this is my personal biased suggestion, and it is not a rule by any means."
  },
  {
    "objectID": "1-03-vectors-creation.html#default-vectors",
    "href": "1-03-vectors-creation.html#default-vectors",
    "title": "3  Creating Vectors",
    "section": "3.2 Default Vectors",
    "text": "3.2 Default Vectors\nR comes with a set of functions to initialize vectors of a specific data type. The generic function is vector() but there are also type-specific versions:\n\nvector()\nlogical()\ninteger()\ndouble() and numeric()\ncharacter()\n\nThe function vector(), as the name indicates, lets you create a vector of a given mode and of a certain length. By default, vector() creates a \"logical\" vector of length = 0.\n\nlog = vector()\nlog\n\nlogical(0)\n\nlength(log)\n\n[1] 0\n\n\nNotice what happens when you print log, the output displayed is: logical(0). This is the notation that R uses to indicate that a vector is of length zero. The previous call is equivalent to:\n\nvector(mode = \"logical\", length = 0)\n\nA common question that some useRs have when they encounter things like logical(0) is “when do you use zero-length vectors”? The quick answer is: you can use zero-length vectors to initialize a vector that will later be populated with more elements. This typically happens when you know that a vector of certain type is needed to store several values, but you don’t know in advance how many elements will be computed.\nAll the other functions, e.g. logical(), integer(), etc, take just one argument length to indicate the number of elements of the output vector. Keep in mind that the value(s) of the initialized vector cannot be changed:\n\nlogical(length = 1)\n\n[1] FALSE\n\ninteger(length = 2)\n\n[1] 0 0\n\ndouble(length = 3)\n\n[1] 0 0 0\n\ncharacter(length = 4)\n\n[1] \"\" \"\" \"\" \"\""
  },
  {
    "objectID": "1-03-vectors-creation.html#numeric-sequences",
    "href": "1-03-vectors-creation.html#numeric-sequences",
    "title": "3  Creating Vectors",
    "section": "3.3 Numeric Sequences",
    "text": "3.3 Numeric Sequences\nA common situation when creating vectors involves creating numeric sequences. If the numeric sequence is short and simple, it could be created with the combine function c(), for example:\n\ns1 = c(1, 2, 3, 4)\ns1\n\n[1] 1 2 3 4\n\n\nOften, you will have to create less simpler and/or longer sequences. For these purposes there are two useful functions:\n\nthe colon operator \":\"\nthe sequence function seq() and its siblings seq.int(), seq_along() and seq.len()\n\n\n3.3.1 Sequences with :\nThe colon operator : lets you create numeric sequences by indicating the starting and ending values. For instance, if you want to generate an integer sequence starting at 1 and ending at 10, you use this command:\n\nints = 1:10\nints\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nNotice that the colon operator, when used with whole numbers, will produce an integer sequence\n\ntypeof(ints)\n\n[1] \"integer\"\n\n\nHowever, when the starting value is not a whole number, then the generated sequence will be of type double, with one-unit steps. For example:\n\ndbls = 1.5:5.5\ndbls\n\n[1] 1.5 2.5 3.5 4.5 5.5\n\ntypeof(dbls)\n\n[1] \"double\"\n\n\nRun the following commands to see how R generates different sequences:\n1.5:5\n1.5:5.1\n1.5:5.5\n1.5:5.9\nYou can also create a descending sequence by starting with a value on the left-hand side of : that is greater than the value on the right-hand side:\n\n# descending (reversed) sequence\n10:1\n\n [1] 10  9  8  7  6  5  4  3  2  1\n\n\n\n# this also applies to negative numbers\n-10:-1\n\n [1] -10  -9  -8  -7  -6  -5  -4  -3  -2  -1\n\n\n\n\n3.3.2 Sequences with seq()\nThe colon operator : can be very useful but it has its limitations. Its main downside is that the generated sequences are of one-unit steps. But what if you want a sequence with steps different from one-unit? For instance, what if you are interested in something like: 2, 4, 6, 8, ...?\nIn addition to the colon operator, R also provides the more generic seq() function for creating numeric sequences. This function comes with a couple of parameters that let you generate sequences in various forms.\nThe simplest usage of seq() involves passing values for the arguments from (the starting value) and to (the ending value):\n\n# equivalent to 1:10\nseq(from = 1, to = 10)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nAs you can tell, the sequence is created with one-unit steps. But this can be changed with the by argument. Say you want steps of two-units, then specify by = 2:\n\nseq(from = 1, to = 10, by = 2)\n\n[1] 1 3 5 7 9\n\n\nNow, what if you want a decreasing sequence, for example 10, 9, …, 1? You can also use seq() to achieve this goal. The starting value from is 10, the ending value to is 1, and the step size by has to be -1\n\nseq(from = 10, to = 1, by = -1)\n\n [1] 10  9  8  7  6  5  4  3  2  1\n\n\nSometimes you may be interested in creating a sequence of a specific length. When this is the case, you need to use the length.out argument. For example, say we want to start with 2, getting the sequence of the first six even numbers. One way to obtain this sequence is with from = 2, steps of size by = 2, and a length of length.out = 6\n\nseq(from = 2, length.out = 6, by = 2)\n\n[1]  2  4  6  8 10 12\n\n\n\n\n3.3.3 Sequences with seq_len() and seq_along()\nseq() comes with sibling functions such as seq.int(), seq_len() and seq_along(). These are more specialized functions than the generic seq(), and they can be more efficient to generate certain sequences.\nThe function seq.int() is designed to generate integer sequences. The difference against seq() is that seq.int() is more efficient:\n\n# equivalent to seq(from = 5, to = 10), but more efficient\nseq.int(from = 5, to = 10)\n\n[1]  5  6  7  8  9 10\n\n\nIf you want a sequence of consecutive positive integers starting at 1, seq_len() is your friend:\n\n# equivalent to seq(from = 1, to = 10), but more efficient\nseq_len(10)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nThe third type of sequence function is seq_along(). This function takes a vector of any length, and it produces a sequence of consecutive positive integers of the same length as the input vector.\n\naccounts = c(\"savings\", \"checking\", \"brokerage\", \"retirement\")\nseq_along(accounts)\n\n[1] 1 2 3 4\n\n\nIf the input vector has length zero, then seq_along() returns zero\n\nnull = NULL  # length(null) is zero\nseq_along(null)\n\ninteger(0)"
  },
  {
    "objectID": "1-03-vectors-creation.html#replicated-vectors",
    "href": "1-03-vectors-creation.html#replicated-vectors",
    "title": "3  Creating Vectors",
    "section": "3.4 Replicated Vectors",
    "text": "3.4 Replicated Vectors\nSome times you need to create vectors containing repeated elements. To do this you can use the function rep(). This function takes a vector as the main input, and then it optionally takes various arguments: times, length.out, and each that let you control the way in which the elements of the input vector should be repeated.\n\nrep(1, times = 5)        # repeat 1 five times\n\n[1] 1 1 1 1 1\n\nrep(c(1, 2), times = 3)  # repeat 1 2 three times\n\n[1] 1 2 1 2 1 2\n\nrep(c(1, 2), each = 2)   # each element repeated twice\n\n[1] 1 1 2 2\n\nrep(c(1, 2), length.out = 5)  # repeat until length of 5\n\n[1] 1 2 1 2 1\n\n\nHere are two less simple examples:\n\nrep(c(3, 2, 1), times = 3:1)\n\n[1] 3 3 3 2 2 1\n\nrep(c(3, 2, 1), times = 3, each = 2)\n\n [1] 3 3 2 2 1 1 3 3 2 2 1 1 3 3 2 2 1 1"
  },
  {
    "objectID": "1-03-vectors-creation.html#coercion",
    "href": "1-03-vectors-creation.html#coercion",
    "title": "3  Creating Vectors",
    "section": "3.5 Coercion",
    "text": "3.5 Coercion\nOne of the basic properties of vectors that you learned in the preceding chapter is that vectors are atomic objects. This is just the fancy way to say that all the elements of a vector have to be of the same data type. If I show you the following vectors, and ask you about their data types, you should have no problem answering this question:\n\none = c(TRUE, FALSE)\ntwo = 2:4\nthree = c(11, 22, 33)\nfour = c(\"one\", \"two\", \"three\")\n\nIf you have doubts about the data type of any of the above vectors, recall that you can use typeof() to get the answer.\nBut what if I create vectors by mixing elements of different data types? For example:\n\nuno = c(FALSE, 1L)    # logical & integer\ndos = c(1L, 2L, 3)    # integer & double\ntres = c(1, 2, \"3\")   # double & character\n\nEnter coercion principles!\nCoercion is another fundamental concept that you should learn about vectors. This has to do with the mechanisms that R uses to make sure that all the elements in a vector are of the same data type.\nThere are two coercion mechanisms or approaches:\n\nimplicit coercion rules\nexplicit coercion functions\n\n\n3.5.1 Implicit Coercion Rules\nImplicit coercion is what R does when we try to combine values of different types into a single vector. Here’s an example:\n\nmixed <- c(TRUE, 1L, 2.0, \"three\")\nmixed\n\n[1] \"TRUE\"  \"1\"     \"2\"     \"three\"\n\n\nIn this command we are mixing different data types: a logical TRUE, an integer 1L, a double 2.0, and a character \"three\". Now, even though the input values are of different data flavors, R has decided to convert everything into type \"character\". Technically speaking, R has implicitly coerced the values as characters, without asking for our permission and without even letting us know that it did so.\nIf you are not familiar with implicit coercion rules, you may get an initial impression that R is acting weirdly, in a nonsensical form. The more you get familiar with R, you will notice some interesting coercion patterns. But you don’t need to struggle figuring out what R will do. You just have to remember the following hierarchy:\n\\[\n\\mathsf{character > double > integer > logical}\n\\]\nHere’s how R works in terms of coercion:\n\ncharacters have priority over other data types: as long as one element is a character, all other elements are coerced into characters\nif a vector has numbers (double and integer) and logicals, double will dominate\nfinally, when mixing integers and logicals, integers will dominate\n\nAlso, when certain operations are applied to certain data types, R may apply its coercion rules. An example of this behavior is when you have a logical vector on which you apply arithmetic operations:\n\n# logical vector\nlogs = c(TRUE, FALSE, TRUE)\n\n# addition (creates integers)\nlogs2 = logs + logs\ntypeof(logs2)\n\n[1] \"integer\"\n\n# multiplication (creates doubles)\nlogs3 = logs * 3\ntypeof(logs3)\n\n[1] \"double\"\n\n\n\n\n3.5.2 Explicit Coercion Functions\nThe other type of coercion mechanism, known as explicit coercion, is done when you explicitly tell R to convert a certain type of vector into a different data type by using explicit coercion functions such as:\n\nas.integer()\nas.double()\nas.character()\nas.logical()\n\nDepending on the type of input vector, and the coercion function, you may achieve what you want, or R may fail to convert things accordingly.\nWe can take deposit, which is of type double, and convert it into an integer with no issues:\n\nint_deposit = as.integer(deposit)\nint_deposit\n\n[1] 1000\n\n\nInterestingly, the way an integer number is displayed is exactly the same as its double version. To confirm that int_deposit is indeed of type integer you can use the is.integer() function\n\nis.integer(deposit)\n\n[1] FALSE\n\nis.integer(int_deposit)\n\n[1] TRUE\n\n\nWhat about trying to convert a character string such as \"string\" into an integer? You can try to apply as.integer() but in this case the attempt is fruitless:\n\nas.integer(\"string\")\n\nWarning: NAs introduced by coercion\n\n\n[1] NA"
  },
  {
    "objectID": "1-03-vectors-creation.html#exercises",
    "href": "1-03-vectors-creation.html#exercises",
    "title": "3  Creating Vectors",
    "section": "3.6 Exercises",
    "text": "3.6 Exercises\n1) What is the data type—as returned by typeof()—of each of the following vectors. Try guessing the data type without running any commands.\n\nx: where x <- c(TRUE, FALSE)\ny: where y <- c(x, 10)\nz: where z <- c(y, 10, \"a\")\n\n\n\nShow answer\nx = c(TRUE, FALSE)\ny = c(x, 10)\nz = c(y, 10, \"a\")\n\ntypeof(x)\ntypeof(y)\ntypeof(z)\n\n\n\n2) What is the data type—as returned by typeof()—of each of the following vectors. Try guessing the data type without running any commands.\n\nx: where x <- c('1', '2', '3', '4')\ny: where y <- (x == 1)\nz: where z <- y + 0\nw: where w <- c(x, \"5.5\")\nyz1: where yz1 <- c(y, z, pi)\n\n\n\nShow answer\nx <- c('1', '2', '3', '4')\ny <- (x == 1)\nz <- y + 0\nw <- c(x, \"5.5\")\nyz1 <- c(y, z, pi)\n\ntypeof(x)\ntypeof(y)\ntypeof(z)\ntypeof(w)\ntypeof(yz1)\n\n\n\n3) Consider the data—about so-called Terrestrial planets—provided in the table below. These planets include Mercury, Venus, Earth, and Mars. They are called terrestrial because they are “Earth-like” planets in contrast to the Jovian planets that involve planets similar to Jupiter (i.e. Jupiter, Saturn, Uranus and Neptune). The main characteristics of terrestrial planets is that they are relatively small in size and in mass, with a solid rocky surface, and metals deep in its interior.\n\n\n\nplanet\ngravity\ndaylength\ntemp\nmoons\nhaswater\n\n\n\n\nMercury\n3.7\n4222.6\n167\n0\nFALSE\n\n\nVenus\n8.9\n2802\n464\n0\nFALSE\n\n\nEarth\n9.8\n24\n15\n1\nTRUE\n\n\nMars\n3.7\n24.7\n-65\n2\nTRUE\n\n\n\nCreate vectors for each of the columns in the data table displayed above, according to the following data-type specifications:\n\nplanet: character vector\ngravity: real (i.e. double) vector (\\(m/s^2\\))\ndaylength: real (i.e. double) vector (hours)\ntemp: integer vector (mean temperature in Celsius)\nmoons: integer vector (number of moons)\nhaswater: logical vector indicating whether a planet has known bodies of liquid water on its surface\n\n\n\nShow answer\nplanet = c(\"Mercry\", \"Venus\", \"Earth\", \"Mars\")\ngravity = c(3.7, 8.9, 9.8, 3.7)\ndaylength = c(4222.6, 2802, 24, 24.7)\ntemp = c(167L, 464L, 15L, -65L)\nmoons = c(0L, 0L, 1L, 2L)\nhaswater = c(FALSE, FALSE, TRUE, TRUE)\n\n\n\n4) Refer to the vectors created in the previous question. Without running any R commands, try to guess the data type—as returned by typeof()—if you had to create a new vector by combining, i.e. using the function c(), the following:\n\nplanets with gravity\nplanets with temp\nplanets with haswater\ngravity with daylength\ngravity with temp\ntemp with moons\ntemp with haswater\n\n\n5) Figure out how to use the function seq() to create the following vector\n\n\n [1] 1.0 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2.0\n\n\n\n\nShow answer\nseq(from = 1, to = 2, by = 0.1)\n\n\n\n6) Figure out how to use the function seq() to create the following vector\n\n\n [1] 1000  900  800  700  600  500  400  300  200  100\n\n\n\n\nShow answer\nseq(from = 1000, to = 100, by = -100)\n\n\n\n7) Figure out how to use the colon operator : to create the following vector\n\n\n [1]  5  4  3  2  1  0 -1 -2 -3 -4 -5\n\n\n\n\nShow answer\n5:-5\n\n\n\n8) Figure out how to use the colon operator : to create the following vector\n\n\n[1] 9.25 8.25 7.25 6.25 5.25 4.25 3.25 2.25 1.25\n\n\n\n\nShow answer\n9.25:1.25\n\n\n\n9) Find out how to use the function rep() and the input vector 1:3 to create the following vector:\n\n\n[1] 1 1 2 2 3 3\n\n\n\n\nShow answer\nrep(1:3, each = 2)\n\n\n\n10) Find out how to use the function rep() and the input vector 1:3 to create the following vector:\n\n\n[1] 1 2 3 1 2 3\n\n\n\n\nShow answer\nrep(1:3, times = 2)\n\n\n\n11) Find out how to use the function rep() and the input vector 1:4 to create the following vector:\n\n\n [1] 1 2 2 3 3 3 4 4 4 4\n\n\n\n\nShow answer\nrep(1:4, each = 1:4)\n\n\n\n12) Use the seq() function to create vectors for each of the following parts, and find their sum().\n\nWhat is the sum of the first 100 positive odd numbers?\n\n\n\n\n\n\nShow answer\nx = seq(from = 1, by = 2, length.out = 100)\nsum(x)\n\n\n\nFind the sum of the first 64 terms of the arithmetic series: \\(3 + 9 + 15 + 21 + \\dots\\)\n\n\n\n\n\n\nShow answer\nx = seq(from = 3, by = 6, length.out = 64)\nsum(x)\n\n\n\nFind the partial sum of the arithmetic series below: \\(7 + 12 + 17 + 22 + \\dots + 187\\)\n\n\n\n\n\n\nShow answer\nx = seq(from = 7, to = 187, by = 5)\nsum(x)"
  },
  {
    "objectID": "1-04-vectors-concepts.html",
    "href": "1-04-vectors-concepts.html",
    "title": "4  More About Vectors",
    "section": "",
    "text": "In the previous chapter we started the topic of data objects by introducing R vectors and some of their basic properties. In this chapter we continue the discussion of vectors, specifically the notions of vectorization, recycling, and subsetting."
  },
  {
    "objectID": "1-04-vectors-concepts.html#motivation-future-value",
    "href": "1-04-vectors-concepts.html#motivation-future-value",
    "title": "4  More About Vectors",
    "section": "4.1 Motivation: Future Value",
    "text": "4.1 Motivation: Future Value\nLet’s bring back the savings example from the previous chapters: you have $1000 and you decide to deposit this money in a savings account that pays you an annual interest rate of 2%. We’ve already seen how to calculate the amount of money that you would have at the end of the first, second and third years. Let’s now calculate the saved amount for a 10-year period.\n\nHow much money will you have at the end of each year during a 10-year period?\n\nTo answer this question, we could compute individual amount objects (e.g.  amount1, amount2, amount3, etc) to get the saved amount at the end of each year. For example:\n\n# inputs\ndeposit <- 1000\nrate <- 0.02\n\n# amounts at the end of years 1, 2, 3, ..., 10\namount1 = deposit * (1 + rate)\namount2 = amount1 * (1 + rate)\namount3 = amount2 * (1 + rate)\namount4 = amount3 * (1 + rate)\namount5 = amount4 * (1 + rate)\namount6 = amount5 * (1 + rate)\namount7 = amount6 * (1 + rate)\namount8 = amount7 * (1 + rate)\namount9 = amount8 * (1 + rate)\namount10 = amount8 * (1 + rate)\n\nThe problem with this piece of code is that it is too repetitive, time consuming, boring, and error prone (can you spot the error?). Even worse, imagine if you were interested in computing the amount of your investment for a 20-year or a 30-year or a longer year period?\nThe good news is that we don’t have to be so repetitive. Before describing what the alternative—and more efficient—approach is, we need to do a bit of algebra.\n\n4.1.1 Future Value Formula\nIn one year you’ll have:\n\\[\n1000 \\times (1.02) = 1020\n\\]\nIn two years you’ll have:\n\\[\n1000 \\times (1.02) \\times (1.02) = 1000 \\times (1.02)^2 = 1040.4\n\\]\nIn three years you’ll have:\n\\[\n1000 \\times (1.02) \\times (1.02) \\times (1.02) = 1000 \\times (1.02)^3 = 1061.208\n\\]\nDo you see a pattern?\nIf you deposit $1000 at a rate of return \\(r\\), how much will you have at the end of year \\(t\\)? The answer is given by the Future Value (FV) formula. In its simplest version, the formula is:\n\\[\n\\text{FV} = \\text{PV} \\times (1 + r)^n\n\\]\n\n\\(\\text{FV}\\) = future value (how much you’ll have)\n\\(\\text{PV}\\) = present value (the initial deposit)\n\\(r\\) = rate of return (e.g. annual rate of return)\n\\(n\\) = number of periods (e.g. number of years)\n\nKeep in mind that there are more sophisticated versions of the FV formula. For now, let’s keep things simple and use the above equation.\nIf you deposit $1000 at a rate of 2%, how much will you have at the end of year 10?\n\ndeposit <- 1000\nrate <- 0.02\nyear <- 10\n\namount10 <- deposit * (1 + rate)^year\namount10\n\n[1] 1218.994\n\n\nUsing the formula of the Future Value you can directly compute the amount that you would have at the end of the tenth year. But what about calculating the amounts at the end of each year during that time period? Enter vectorization!"
  },
  {
    "objectID": "1-04-vectors-concepts.html#vectorization",
    "href": "1-04-vectors-concepts.html#vectorization",
    "title": "4  More About Vectors",
    "section": "4.2 Vectorization",
    "text": "4.2 Vectorization\nIn order to explain what vectorization is, let me first show you the following R code. Compared to the code snippet above, note that the code below uses a vector years containing a numeric sequence from 1 to 10, thanks to the : (“colon”) operator. This vector years is then used to play the role of the exponent in the Future Value formula:\n\ndeposit <- 1000\nrate <- 0.02\nyears <- 1:10  # vector of years\n\n# example of vectorization (or vectorized code)\namounts <- deposit * (1 + rate)^years\namounts\n\n [1] 1020.000 1040.400 1061.208 1082.432 1104.081 1126.162 1148.686 1171.659\n [9] 1195.093 1218.994\n\n\nThe computed object amounts is exactly what we are looking for. This vector contains the saved amounts at the end of each year, from the first year till the tenth year.\nThe code used to obtain amounts is an example of one of the most fundamental and powerful kinds of operations (computations) in R, and it has its special name: vectorization, also referred to as vectorized code.\nWhen you write code like this:\n\namounts = deposit * (1 + rate)^years\n\nwe say that your code is vectorized. Technically speaking, this code uses not just vectorization but it also uses something else called recycling, which we will explain in the next section. But let’s describe vectorization first.\n\nSo what is vectorization?\nSimply put, vectorization means that a given function or operation will be applied to all the elements of one or more vectors, element by element.\nSay you want to create a vector log_amounts by taking the logarithm of amounts. All you have to do is apply the log() function to amounts:\nlog_amounts <- log(amounts)\nWhen you create the vector log_amounts, what you’re doing is applying a function to a vector, which in turn acts on all the elements of the vector. Hence the reason why, in R parlance, we call it vectorization.\nMost functions that operate with vectors in R are vectorized functions. This means that an action is applied to all elements of the vector without the need to explicitly type commands to traverse all of its values, element by element.\nIn many other programming languages, you would have to use a set of commands to loop over each element of a vector (or list of numbers) to transform them. But not in R.\nAnother simple example of vectorization would be the calculation of the square root of all the amounts:\n\nsqrt(amounts)\n\n [1] 31.93744 32.25523 32.57619 32.90034 33.22771 33.55834 33.89227 34.22951\n [9] 34.57011 34.91410\n\n\nBe careful. Not every function that takes in a vector is necessarily vectorized. An example of a function that does not perform vectorization is the mean() function:\n\nmean(amounts)\n\n[1] 1116.872\n\n\nAs expected, mean() returns the average or mean value of all the numeric values in the vector amounts. It is not vectorized because it does compute the mean of every element of the input vector.\nSo be careful, just because a function does a computation with an input vector, it does not mean that its vectorized. Vectorization happens when the same function or action is applied to every element of a vector.\n\n\nWhy should you care about vectorization?\nIf you are new to programming, learning about R’s vectorization will be very natural and you won’t stop to think about it too much. If you have some previous programming experience in other languages (e.g. C, python, perl), you know that vectorization does not tend to be a native thing.\nVectorization is essential in R. It saves you from typing many lines of code, and you will exploit vectorization with other useful functions known as the apply family functions (we’ll talk about them later in the book)."
  },
  {
    "objectID": "1-04-vectors-concepts.html#recycling",
    "href": "1-04-vectors-concepts.html#recycling",
    "title": "4  More About Vectors",
    "section": "4.3 Recycling",
    "text": "4.3 Recycling\nClosely related with the concept of vectorization we have the notion of Recycling. To explain recycling let’s see an example.\nThe values in the vector amounts are given in dollars, but what if you need to convert them into values expressed in thousands of dollars?. To convert from dollars to thousands-of-dollars you just need to divide by 1000; for example\n\n1,000 dollars becomes 1 thousands-dollars\n10,000 dollars becomes 10 thousands-dollars\n1 dollar becomes 0.001 thousands-dollars\n\nHere is how to create a new vector thousands:\n\nthousands <- amounts / 1000\nthousands\n\n [1] 1.020000 1.040400 1.061208 1.082432 1.104081 1.126162 1.148686 1.171659\n [9] 1.195093 1.218994\n\n\nWhat you just did (assuming that you did things correctly) is called Recycling, which is what R does when you operate with two (or more) vectors of different length.\nTo understand this concept, you need to remember that R does not have a data structure for scalars (single numbers). Scalars are in reality vectors of length 1.\nThe conversion from dollars to thousands-of-dollars requires this operation: amounts / 1000. Although it may not be obvious, we are operating with two vectors of different length: amounts has 10 elements, whereas 1000 is a one-element vector. So how does R know what to do in this case?\nWell, R uses its recycling principle, which takes the shorter vector (in this case 1000) and recycles its content to form a temporary vector that matches the length of the longer vector (i.e. amounts).\n\nAnother recycling example\nHere’s another example of recycling. Saved amounts of elements in an odd number position will be divided by two; values of elements in an even number position will be divided by 10:\n\nunits <- c(1/2, 1/10)\nnew_amounts <- amounts * units\nnew_amounts\n\n [1] 510.0000 104.0400 530.6040 108.2432 552.0404 112.6162 574.3428 117.1659\n [9] 597.5463 121.8994\n\n\nIn this piece of code, the elements of units are recycled (i.e. repeated) as many times as the number of elements in amounts.\nTo achieve the same result without using recycling you would have to create a vector new_units (i.e. the values to divide by) of the same length as amounts. For example, you could create a vector new_units with the replicate function rep() having ten elements in which those values in odd positions are 1/2 and those values in even positions are 1/10:\n\nnew_units <- rep(c(1/2, 1/10), length.out = length(amounts))\namounts * new_units\n\n [1] 510.0000 104.0400 530.6040 108.2432 552.0404 112.6162 574.3428 117.1659\n [9] 597.5463 121.8994\n\n\n\n\n4.3.1 Vectorization and Recycling\nLet’s bring back the code that uses the Future Value to obtain the vector amounts:\n\namounts = deposit * (1 + rate)^years\n\nRecall that deposit and rate are vectors of length 1. And so it is the number 1, it is a vector containing just one element. In contrast, years has 10 elements. This means that R is dealing with four vectors some of which have different lengths.\nIn pictures, we have the following diagram:\n\n\n\n\n\nDiagram depicting vectors of different lengths.\n\n\n\n\nHow does R take care of this?\nThe following diagram depicts what R does behind the scenes: R recycles the shorter vectors to match the length of the longest vector. In this example, vectors deposit, rate, and 1 are the shorter vectors, which are then recycle to match the length of the longest vector years. The computation process is completed with vectorization.\n\n\n\n\n\n\n\n\n\nAs you can tell, this is an example of vectorization & recycling rules in R."
  },
  {
    "objectID": "1-04-vectors-concepts.html#manipulating-vectors-subsetting",
    "href": "1-04-vectors-concepts.html#manipulating-vectors-subsetting",
    "title": "4  More About Vectors",
    "section": "4.4 Manipulating Vectors: Subsetting",
    "text": "4.4 Manipulating Vectors: Subsetting\nIn addition to creating vectors, you should also learn how to do some basic manipulation of vectors. The most common type of manipulation is called subsetting, also known as indexing or subscripting, which we use to extract and also replace elements of a vector (or another R object). To do so, you use what I like to call bracket notation. This implies using (square) brackets [ ] to get access to the elements of a vector.\nTo subset a vector, you type the name of the vector, followed by an opening and a closing bracket. Inside the brackets you specify an indexing vector which could be a numeric vector, a logical vector, and sometimes a character vector. Let’s see these options in more detail in the following subsections.\n\n\n\n\n\nUse of brackets for subscripting vectors.\n\n\n\n\n\n4.4.1 Numeric Subsetting\nThis type of subsetting, as the name indicates, is when the indexing vector consists of a numeric vector with one or more values that correspond to the position(s) of the vector element(s).\nThe simplest type of numeric subsetting is when we use a single number (which is a vector of length one).\n\n# amount at end of year 1\namounts[1]\n\n[1] 1020\n\n\nThe numeric indexing vector can have more than one element. For example, if we want to extract the elements in positions 1, 2 and 3, we could provide a numeric sequence 1:3:\n\n# amounts at end of years 1, 2, and 3\namounts[1:3]\n\n[1] 1020.000 1040.400 1061.208\n\n\nThe numeric positions don’t have to be consecutive numbers. You can also use a vector of non-consecutive numbers:\n\n# amounts at end of years 2 and 4\namounts[c(2, 4)]\n\n[1] 1040.400 1082.432\n\n\nLikewise, we can also use a vector with repeated numbers:\n\n# repeated amounts\namounts[c(2, 2, 2)]\n\n[1] 1040.4 1040.4 1040.4\n\n\nIn addition to the previous subscripting options, we can specify negative numbers to indicate that we want to exclude an element in the associated position:\n\n# exclude 2nd year\namounts[-2]\n\n[1] 1020.000 1061.208 1082.432 1104.081 1126.162 1148.686 1171.659 1195.093\n[9] 1218.994\n\n# exclude 2nd and 4th years\namounts[-c(2, 4)]\n\n[1] 1020.000 1061.208 1104.081 1126.162 1148.686 1171.659 1195.093 1218.994\n\n\n\n\n4.4.2 Character Subsetting\nSometimes, you may have a vector with named elements. When this is the case, you can use a character vector—containing one or more of the element names—as the indexing vector.\nNone of the vectors that we have created so far have named elements. So let’s see how to do this. One way to give names to the elements of an existing vector is with the function names()\n\namounts3 = amounts[1:3]\nnames(amounts3) = c(\"y1\", \"y2\", \"y3\")\namounts3\n\n      y1       y2       y3 \n1020.000 1040.400 1061.208 \n\n\nWhen a vector, like amounts3, has named elements, we can use those names for subsetting purposes. Instead of using a numeric vector we use a character vector. Hence the term character subsetting.\nFor example, to extract the element in amounts3 that has name \"y1\" we pass this string inside the brackets:\n\namounts3[\"y1\"]\n\n  y1 \n1020 \n\n\nTo get the elements in amounts3 that have names \"y1\" and \"y3\", we can write\n\namounts3[c(\"y1\", \"y3\")]\n\n      y1       y3 \n1020.000 1061.208 \n\n\nAnd like in the numeric subsetting case, we can also write a command such as:\n\namounts3[c(\"y2\", \"y2\", \"y2\", \"y1\")]\n\n    y2     y2     y2     y1 \n1040.4 1040.4 1040.4 1020.0 \n\n\n\n\n4.4.3 Logical Subsetting\nAnother type of subsetting is when we use a logical vector as the indexing vector.\nLet me show you an example of logical subsetting. In this case, we will use a logical vector with three elements c(TRUE, FALSE, FALSE) and pass this inside the brackets:\n\namounts3[c(TRUE, FALSE, FALSE)]\n\n  y1 \n1020 \n\n\nAs you can tell, the retrieved element in amounts3 is the one associated to the TRUE position, whereas those elements associated to the FALSE values are excluded. This is how the logical values (in the indexing vector) are used:\n\nTRUE means inclusion\nFALSE means exclusion\n\nSo, if we want to extract only the element in the second position, we could write something like this:\n\namounts3[c(FALSE, TRUE, FALSE)]\n\n    y2 \n1040.4 \n\n\nNow, I have to say that doing logical subsetting in this way is not really how we tend to use it in practice. In other words, we won’t be providing an explicit logical vector, typing a bunch of TRUE’s and FALSE’s values. Instead, what we typically do is to provide a command that, when executed by R, will return a logical vector.\nConsider the following example. We create a vector x, and then we use the greater than symbol > to compute a mathematical comparison which in turn will return a logical vector.\n\nx = c(2, 4, 6, 8)\nx > 5\n\n[1] FALSE FALSE  TRUE  TRUE\n\n\nKnowing that x > 5 produces a logical vector in which FALSE indicates that the number is less than or equal 5, and TRUE indicates that the number is greater than 5, we can write the following command to subset those elements in x that are greater than five:\n\nx[x > 5]\n\n[1] 6 8\n\n\nThis is a simple example of logical subsetting because the indexing vector is the logical vector that comes from executing the comparison x > 5.\nHere is a less simple example of logical subsetting to extract the elements in x that are greater than 3 and less than or equal to 6. This requires\ntwo comparison expressions, x > 3 and x <= 6, and the use of the logical AND operator & to form a compound logical comparison:\n\nx[x > 3 & x <= 6]\n\n[1] 4 6\n\n\n\n\n4.4.4 Summary of Subsetting\nIn summary, the things that you can specify inside the brackets are three kind of vectors:\n\nnumeric vectors\nlogical vectors (the length of the logical vector must match the length of the vector to be subset)\ncharacter vectors (if the elements have names)\n\nIn addition to the brackets [], some common functions that you can use on vectors are:\n\nlength() gives the number of values\nsort() sorts the values in increasing or decreasing ways\nrev() reverses the values\nunique() extracts unique elements\n\nlength(amounts3)\namounts3[length(amounts3)]\nsort(amounts3, decreasing = TRUE)\nrev(amounts3)"
  },
  {
    "objectID": "1-04-vectors-concepts.html#exercises",
    "href": "1-04-vectors-concepts.html#exercises",
    "title": "4  More About Vectors",
    "section": "4.5 Exercises",
    "text": "4.5 Exercises\n1) Explain, in your own words, the concept of vectorization a.k.a. vectorized operations in R.\n\n\nShow answer\n# Vectorization (or vectorized code) is when R applies calculations or \n# operations to all the elements of a vector (element-wise)\n\n\n\n2) Explain, in your own words, the recycling principle in R.\n\n\nShow answer\n# Recycling is what R does when you perform a calculation with vectors \n# of different length\n\n\n\n3) Write 2 different R commands to return the first five elements of a vector x (assume x has more than 5 elements).\n\n\nShow answer\nx[1:5]\nhead(x, 5)\n\n\n\n4) Suppose y <- c(1, 4, 9, 16, 25). Write down the R command to return a vector z, in which each element of z is the square root of each element of the vector y.\n\n\nShow answer\ny <- c(1, 4, 9, 16, 25)\n\nz <- sqrt(y)\n\n\n\n5) Which command will fail to return the first five elements of a vector x? (assume x has more than 5 elements).\n\nx[1:5]\nx[c(1,2,3,4,5)]\nhead(x, n = 5)\nx[seq(1, 5)]\nx(1:5)\n\n\n\nShow answer\n# command e)\n\n\n\n6) For each the following parts, state whether the given function or operator is vectorized, and provide a code example to support your claim.\n\nlength()\n*\nlog()\nmax()\ntrunc()\n\n\n\nShow answer\n# a) not vectorized\n# b) vectorized\n# c) vectorized\n# d) not vectorized\n# e) vectorized\n\n\n\n7) Consider the following code to obtain vectors name and mpg from the data set mtcars that contains data about 32 automobiles (1973–74 models).\n\n# vectors name and mpg\nname = rownames(mtcars)\nmpg = mtcars$mpg\n\nUse seq(), and bracket notation, to subset (extract):\n\nall the even elements in name (i.e. extract positions 2, 4, 6, etc)\n\n\n\nShow answer\nname[seq(from = 2, to = length(name), by = 2)]\n\n\n\nall the odd elements in mpg (i.e. extract positions 1, 3, 5, etc)\n\n\n\nShow answer\nmpg[seq(from = 1, to = length(mpg), by = 2)]\n\n\n\nall the elements in positions multiples of 5 (e.g. extract positions 5, 10, 15, etc) of mpg\n\n\n\nShow answer\nmpg[seq(from = 5, to = length(mpg), by = 5)]\n\n\n\nall the even elements in name but this time in reverse order; hint the rev() function is your friend.\n\n\n\nShow answer\nname[seq(from = length(name), to = 2, by = -2)]\n\n# equivalently\nrev(name[seq(from = 2, to = length(name), by = 2)])\n\n\n\n8) Consider the following code to obtain vectors name, mpg and cyl from the data set mtcars that contains data about 32 automobiles (1973–74 models).\n\n# vectors name, mpg and cyl\nname = rownames(mtcars)\nmpg = mtcars$mpg # miles-per-gallon\ncyl = mtcars$cyl  # number of cylinders\n\nWrite commands, using bracket notation, to answer the parts listed below. You may need to use is.na(), sum(), min(), max(), which(), which.min(), which.max():\n\nname of cars that have a fuel consumption of less than 15 mpg\n\n\n\nShow answer\nname[mpg < 15]\n\n\n\nname of cars that have 6 cylinders\n\n\n\nShow answer\nname[cyl == 6]\n\n\n\nlargest mpg value of all cars with 8 cylinders\n\n\n\nShow answer\nmax(mpg[cyl == 8])\n\n\n\nname of car(s) with mpg equal to the median mpg\n\n\n\nShow answer\nname[mpg == median(mpg)]\n\n\n\nname of car(s) with mpg of at most 22, and at least 6 cylinders\n\n\n\nShow answer\nname[mpg <= 22 & cyl >= 6]"
  },
  {
    "objectID": "2-01-factors.html",
    "href": "2-01-factors.html",
    "title": "5  Factors",
    "section": "",
    "text": "I’m one of those with the humble opinion that great software for data science and analytics should have a data structure dedicated to handle categorical data. Luckily, one of the nicest features about R is that it provides a data object exclusively designed to handle categorical data: factors.\nThe term “factor” as used in R for handling categorical variables, comes from the terminology used in Analysis of Variance, commonly referred to as ANOVA. In this statistical method, a categorical variable is commonly referred to as, surprise-surprise, factor and its categories are known as levels. Perhaps this is not the best terminology but it is the one R uses, which reflects its distinctive statistical origins. Especially for those users without a background in statistics, this is one of R’s idiosyncrasies that seems disconcerting at the beginning. But as long as you keep in mind that a factor is just the object that allows you to handle a qualitative variable you’ll be fine. In case you need it, here’s a short mantra to remember:"
  },
  {
    "objectID": "2-01-factors.html#creating-factors",
    "href": "2-01-factors.html#creating-factors",
    "title": "5  Factors",
    "section": "5.1 Creating Factors",
    "text": "5.1 Creating Factors\nTo create a factor in R you use the homonym function factor(), which takes a vector as input. The vector can be either numeric, character or logical. Let’s see our first example:\n\n# numeric vector\nnum_vector <- c(1, 2, 3, 1, 2, 3, 2)\n\n# creating a factor from num_vector\nfirst_factor <- factor(num_vector)\n\nfirst_factor\n\n[1] 1 2 3 1 2 3 2\nLevels: 1 2 3\n\n\nAs you can tell from the previous code snippet, factor() converts the numeric vector num_vector into a factor (i.e. a categorical variable) with 3 categories—the so called levels.\nYou can also obtain a factor from a string vector:\n\n# string vector\nstr_vector <- c('a', 'b', 'c', 'b', 'c', 'a', 'c', 'b')\n\nstr_vector\n\n[1] \"a\" \"b\" \"c\" \"b\" \"c\" \"a\" \"c\" \"b\"\n\n# creating a factor from str_vector\nsecond_factor <- factor(str_vector)\n\nsecond_factor\n\n[1] a b c b c a c b\nLevels: a b c\n\n\nNotice how str_vector and second_factor are displayed. Even though the elements are the same in both the vector and the factor, they are printed in different formats. The letters in the string vector are displayed with quotes, while the letters in the factor are printed without quotes.\nAnd of course, you can use a logical vector to generate a factor as well:\n\n# logical vector\nlog_vector <- c(TRUE, FALSE, TRUE, TRUE, FALSE)\n\n# creating a factor from log_vector\nthird_factor <- factor(log_vector)\n\nthird_factor\n\n[1] TRUE  FALSE TRUE  TRUE  FALSE\nLevels: FALSE TRUE"
  },
  {
    "objectID": "2-01-factors.html#how-r-treats-factors",
    "href": "2-01-factors.html#how-r-treats-factors",
    "title": "5  Factors",
    "section": "5.2 How R treats factors",
    "text": "5.2 How R treats factors\nTechnically speaking, R factors are referred to as compound objects. According to the “R Language Definition” manual:\n\n“Factors are currently implemented using an integer array to specify the actual levels and a second array of names that are mapped to the integers.”\n\nWhat does this mean?\nEssentially, a factor is internally stored using two ingredients: one is an integer vector containing the values of categories, the other is a vector with the “levels” which has the names of categories which are mapped to the integers.\nUnder the hood, the way R stores factors is as vectors of integer values. One way to confirm this is using the function storage.mode()\n\n# storage of factor\nstorage.mode(first_factor)\n\n[1] \"integer\"\n\n\nThis means that we can manipulate factors just like we manipulate vectors. In addition, many functions for vectors can be applied to factors. For instance, we can use the function length() to get the number of elements in a factor:\n\n# factors have length\nlength(first_factor)\n\n[1] 7\n\n\nWe can also use the square brackets [ ] to extract or select elements of a factor. Inside the brackets we specify vectors of indices such as numeric vectors, logical vectors, and sometimes even character vectors.\n\n# first element\nfirst_factor[1]\n\n# third element\nfirst_factor[3]\n\n# second to fourth elements\nfirst_factor[2:4]\n\n# last element\nfirst_factor[length(first_factor)]\n\n# logical subsetting\nfirst_factor[rep(c(TRUE, FALSE), length.out = 7)]\n\nIf you have a factor with named elements, you can also specify the names of the elements within the brackets:\n\nnames(first_factor) <- letters[1:length(first_factor)]\nfirst_factor\n\na b c d e f g \n1 2 3 1 2 3 2 \nLevels: 1 2 3\n\nfirst_factor[c('b', 'd', 'f')]\n\nb d f \n2 1 3 \nLevels: 1 2 3\n\n\nHowever, you should know that factors are NOT really vectors. To see this you can check the behavior of the functions is.factor() and is.vector() on a factor:\n\n# factors are not vectors\nis.vector(first_factor)\n\n[1] FALSE\n\n# factors are factors\nis.factor(first_factor)\n\n[1] TRUE\n\n\nEven a single element of a factor is also a factor:\n\nclass(first_factor[1])\n\n[1] \"factor\"\n\n\n\nSo what makes a factor different from a vector?\nWell, it turns out that factors have an additional attribute that vectors don’t: levels. And as you can expect, the class of a factor is indeed \"factor\" (not \"vector\").\n\n# attributes of a factor\nattributes(first_factor)\n\n$levels\n[1] \"1\" \"2\" \"3\"\n\n$class\n[1] \"factor\"\n\n$names\n[1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\"\n\n\nAnother feature that makes factors so special is that their values (the levels) are mapped to a set of character values for displaying purposes. This might seem like a minor feature but it has two important consequences. On the one hand, this implies that factors provide a way to store character values very efficiently. Why? Because each unique character value is stored only once, and the data itself is stored as a vector of integers.\nNotice how the numeric value 1 was mapped into the character value \"1\". And the same happens for the other values 2 and 3 that are mapped into the characters \"2\" and \"3\".\n\n\nWhat is the advantage of R factors?\nEvery time I teach about factors, there is inevitably one student who asks a very pertinent question: Why do we want to use factors? Isn’t it redundant to have a factor object when there are already character or integer vectors?\nI have two answers to this question.\nThe first has to do with the storage of factors. Storing a factor as integers will usually be more efficient than storing a character vector. As we’ve seen, this is an important issue especially when the data—to be encoded into a factor—is of considerable size.\nThe second reason has to do with categorical variables of ordinal nature. Qualitative data can be classified into nominal and ordinal variables. Nominal variables could be easily handled with character vectors. In fact, nominal means name (values are just names or labels), and there’s no natural order among the categories.\nA different story is when we have ordinal variables, like sizes \"small\", \"medium\", \"large\" or college years \"freshman\", \"sophomore\", \"junior\", \"senior\". In these cases we are still using names of categories, but they can be arranged in increasing or decreasing order. In other words, we can rank the categories since they have a natural order: small is less than medium which is less than large. Likewise, freshman comes first, then sophomore, followed by junior, and finally senior.\nSo here’s an important question: How do we keep the order of categories in an ordinal variable? We can use a character vector to store the values. But a character vector does not allow us to store the ranking of categories. The solution in R comes via factors. We can use factors to define ordinal variables, like the following example:\n\nsizes <- factor(\n  x = c('sm', 'md', 'lg', 'sm', 'md'),\n  levels = c('sm', 'md', 'lg'),\n  ordered = TRUE)\n\nsizes\n\n[1] sm md lg sm md\nLevels: sm < md < lg\n\n\nAs you can tell, sizes has ordered levels, clearly identifying the first category \"sm\", the second one \"md\", and the third one \"lg\"."
  },
  {
    "objectID": "2-01-factors.html#a-closer-look-at-factor",
    "href": "2-01-factors.html#a-closer-look-at-factor",
    "title": "5  Factors",
    "section": "5.3 A closer look at factor()",
    "text": "5.3 A closer look at factor()\nSince working with categorical data in R typically involves working with factors, you should become familiar with the variety of functions related with them. In the following sections we’ll cover a bunch of details about factors so you can be better prepared to deal with any type of categorical data.\n\n5.3.1 Function factor()\nGiven the fundamental role played by the function factor() we need to pay a closer look at its arguments. If you check the documentation—see help(factor)—you’ll see that the usage of the function factor() is:\n  factor(x = character(), levels, labels = levels,\n         exclude = NA, ordered = is.ordered(x), nmax = NA)\nwith the following arguments:\n\nx a vector of data\nlevels an optional vector for the categories\nlabels an optional character vector of labels for the levels\nexclude a vector of values to be excluded when forming the set of levels\nordered logical value to indicate if the levels should be regarded as ordered\nnmax an upper bound on the number of levels\n\nThe main argument of factor() is the input vector x. The next argument is levels, followed by labels, both of which are optional arguments. Although you won’t always be providing values for levels and labels, it is important to understand how R handles these arguments by default.\n\nArgument levels\nIf levels is not provided (which is what happens in most cases), then R assigns the unique values in x as the category levels.\nFor example, consider our numeric vector from the first example: num_vector contains unique values 1, 2, and 3.\n\n# numeric vector\nnum_vector <- c(1, 2, 3, 1, 2, 3, 2)\n\n# creating a factor from num_vector\nfirst_factor <- factor(num_vector)\n\nfirst_factor\n\n[1] 1 2 3 1 2 3 2\nLevels: 1 2 3\n\n\nNow imagine we want to have levels 1, 2, 3, 4, and 5. This is how you can define the factor with an extended set of levels:\n\n# numeric vector\nnum_vector\n\n[1] 1 2 3 1 2 3 2\n\n# defining levels\none_factor <- factor(num_vector, levels = 1:5)\none_factor\n\n[1] 1 2 3 1 2 3 2\nLevels: 1 2 3 4 5\n\n\nAlthough the created factor only has values between 1 and 3, the levels range from 1 to 5. This can be useful if we plan to add elements whose values are not in the input vector num_vector. For instance, you can append two more elements to one_factor with values 4 and 5 like this:\n\n# adding values 4 and 5\none_factor[c(8, 9)] <- c(4, 5)\none_factor\n\n[1] 1 2 3 1 2 3 2 4 5\nLevels: 1 2 3 4 5\n\n\nIf you attempt to insert an element having a value that is not in the predefined set of levels, R will insert a missing value (<NA>) instead, and you’ll get a warning message like the one below:\n\n# attempting to add value 6 (not in levels)\none_factor[1] <- 6\n\nWarning in `[<-.factor`(`*tmp*`, 1, value = 6): invalid factor level, NA\ngenerated\n\none_factor\n\n[1] <NA> 2    3    1    2    3    2    4    5   \nLevels: 1 2 3 4 5\n\n\n\n\nArgument labels\nAnother very useful argument is labels, which allows you to provide a string vector for naming the levels in a different way from the values in x. Let’s take the numeric vector num_vector again, and say we want to use words as labels instead of numeric values. Here’s how you can create a factor with predefined labels:\n\n# defining labels\nnum_word_vector <- factor(num_vector, labels = c(\"one\", \"two\", \"three\"))\n\nnum_word_vector\n\n[1] one   two   three one   two   three two  \nLevels: one two three\n\n\n\n\nArgument exclude\nIf you want to ignore some values of the input vector x, you can use the exclude argument. You just need to provide those values which will be removed from the set of levels.\n\n# excluding level 3\nfactor(num_vector, exclude = 3)\n\n[1] 1    2    <NA> 1    2    <NA> 2   \nLevels: 1 2\n\n# excluding levels 1 and 3\nfactor(num_vector, exclude = c(1,3))\n\n[1] <NA> 2    <NA> <NA> 2    <NA> 2   \nLevels: 2\n\n\nThe side effect of exclude is that it returns a missing value (<NA>) for each element that was excluded, which is not always what we want. Here’s one way to remove the missing values when excluding 3:\n\n# excluding level 3\nnum_fac12 <- factor(num_vector, exclude = 3)\n\n# oops, we have some missing values\nnum_fac12\n\n[1] 1    2    <NA> 1    2    <NA> 2   \nLevels: 1 2\n\n# removing missing values\nnum_fac12[!is.na(num_fac12)]\n\n[1] 1 2 1 2 2\nLevels: 1 2\n\n\n\n\n\n5.3.2 Unclassing factors\nWe’ve mentioned that factors are stored as vectors of integers (for efficiency reasons). But we also said that factors are more than vectors. Even though a factor is displayed with string labels, the way it is stored internally is as integers. Why is this important to know? Because there will be occasions in which you’ll need to know exactly what numbers are associated to each level values.\nImagine you have a factor with levels 11, 22, 33, 44.\n\n# factor\nxfactor <- factor(c(22, 11, 44, 33, 11, 22, 44))\nxfactor\n\n[1] 22 11 44 33 11 22 44\nLevels: 11 22 33 44\n\n\nTo obtain the integer vector associated to xfactor you can use the function unclass():\n\n# unclassing a factor\nunclass(xfactor)\n\n[1] 2 1 4 3 1 2 4\nattr(,\"levels\")\n[1] \"11\" \"22\" \"33\" \"44\"\n\n\nAs you can see, the levels \"11\", \"22\", \"33\", \"44\" were mapped to the vector of integers (1 2 3 4).\nAn alternative option is to simply apply as.numeric() or as.integer() instead of using unclass():\n\n# equivalent to unclass\nas.integer(xfactor)\n\n[1] 2 1 4 3 1 2 4\n\n# equivalent to unclass\nas.numeric(xfactor)\n\n[1] 2 1 4 3 1 2 4\n\n\nAlthough rarely used, there can be some cases in which what you need to do is revert the integer values in order to get the original factor levels. This is only possible when the levels of the factor are themselves numeric. To accomplish this use the following command:\n\n# recovering numeric levels\nas.numeric(levels(xfactor))[xfactor]\n\n[1] 22 11 44 33 11 22 44"
  },
  {
    "objectID": "2-01-factors.html#ordinal-factors",
    "href": "2-01-factors.html#ordinal-factors",
    "title": "5  Factors",
    "section": "5.4 Ordinal Factors",
    "text": "5.4 Ordinal Factors\nBy default, factor() creates a nominal categorical variable, not an ordinal. One way to check that you have a nominal factor is to use the function is.ordered(), which returns TRUE if its argument is an ordinal factor.\n\n# ordinal factor?\nis.ordered(num_vector)\n\n[1] FALSE\n\n\nIf you want to specify an ordinal factor you must use the ordered argument of factor(). This is how you can generate an ordinal value from num_vector:\n\n# ordinal factor from numeric vector\nordinal_num <- factor(num_vector, ordered = TRUE)\nordinal_num\n\n[1] 1 2 3 1 2 3 2\nLevels: 1 < 2 < 3\n\n\nAs you can tell from the snippet above, the levels of ordinal_factor are displayed with less-than symbols `‘<’}, which means that the levels have an increasing order. We can also get an ordinal factor from our string vector:\n\n# ordinal factor from character vector\nordinal_str <- factor(str_vector, ordered = TRUE)\nordinal_str\n\n[1] a b c b c a c b\nLevels: a < b < c\n\n\nIn fact, when you set ordered = TRUE, R sorts the provided values in alphanumeric order. If you have the following alphanumeric vector (\"a1\", \"1a\", \"1b\", \"b1\"), what do you think will be the generated ordered factor? Let’s check the answer:\n\n# alphanumeric vector\nalphanum <- c(\"a1\", \"1a\", \"1b\", \"b1\")\n\n# ordinal factor from character vector\nordinal_alphanum <- factor(alphanum, ordered = TRUE)\nordinal_alphanum\n\n[1] a1 1a 1b b1\nLevels: 1a < 1b < a1 < b1\n\n\nAn alternative way to specify an ordinal variable is by using the function ordered(), which is just a convenient wrapper for factor(x, ..., ordered = TRUE):\n\n# ordinal factor with ordered()\nordered(num_vector)\n\n[1] 1 2 3 1 2 3 2\nLevels: 1 < 2 < 3\n\n# same as using 'ordered' argument\nfactor(num_vector, ordered = TRUE)\n\n[1] 1 2 3 1 2 3 2\nLevels: 1 < 2 < 3\n\n\nA word of caution. Don’t confuse the function ordered() with order(). They are not equivalent. order() arranges a vector into ascending or descending order, and returns the sorted vector. ordered(), as we’ve seen, is used to get ordinal factors.\nOf course, you won’t always be using the default order provided by the functions factor(..., ordered = TRUE) or ordered(). Sometimes you want to determine categories according to a different order.\nFor example, let’s take the values of str_vector and let’s assume that we want them in descending order, that is, c < b < a. How can you do that? Easy, you just need to specify the levels in the order you want them and set ordered = TRUE (or use ordered()):\n\n# setting levels with specified order\nfactor(str_vector, levels = c(\"c\", \"b\", \"a\"), ordered = TRUE)\n\n[1] a b c b c a c b\nLevels: c < b < a\n\n# equivalently\nordered(str_vector, levels = c(\"c\", \"b\", \"a\"))\n\n[1] a b c b c a c b\nLevels: c < b < a\n\n\nHere’s another example. Consider a set of size values \"xs\" extra-small, \"sm\" small, \"md\" medium, \"lg\" large, and \"xl\" extra-large. If you have a vector with size values you can create an ordinal variable as follows:\n\n# vector of sizes\nsizes <- c(\"sm\", \"xs\", \"xl\", \"lg\", \"xs\", \"lg\")\n\n# setting levels with specified order\nordered(sizes, levels = c(\"xs\", \"sm\", \"md\", \"lg\", \"xl\"))\n\n[1] sm xs xl lg xs lg\nLevels: xs < sm < md < lg < xl\n\n\nNotice that when you create an ordinal factor, the given levels will always be considered in an increasing order. This means that the first value of levels will be the smallest one, then the second one, and so on. The last category, in turn, is taken as the one at the top of the scale.\nNow that we have several nominal and ordinal factors, we can compare the behavior of is.ordered() on two factors:\n\n# is.ordered() on an ordinal factor\nordinal_str\n\n[1] a b c b c a c b\nLevels: a < b < c\n\nis.ordered(ordinal_str)\n\n[1] TRUE\n\n# is.ordered() on a nominal factor\nsecond_factor\n\n[1] a b c b c a c b\nLevels: a b c\n\nis.ordered(second_factor)\n\n[1] FALSE"
  },
  {
    "objectID": "3-01-matrices-intro.html",
    "href": "3-01-matrices-intro.html",
    "title": "6  Matrices and Arrays",
    "section": "",
    "text": "In the previous four chapters, we discussed a number of ideas and concepts that basically have to do with vectors and their cousins factors. You can think of vectors and factors as one-dimensional objects. While many data sets can be handled through vectors and factors, there are occasions in which one dimension is not enough. The classic example for when one-dimensional objects are not enough involves working with data that fits better into a tabular structure consisting of a series of rows (one dimension) and columns (another dimension).\nIn this chapter we introduce R arrays, which are multidimensional atomic objects including 2-dimensional arrays better known as matrices, and N-dimensional generic arrays."
  },
  {
    "objectID": "3-01-matrices-intro.html#motivation",
    "href": "3-01-matrices-intro.html#motivation",
    "title": "6  Matrices and Arrays",
    "section": "6.1 Motivation",
    "text": "6.1 Motivation\nLet us continue discussing the savings-investing scenario in which you deposit $1000 into a savings account that pays you an annual interest rate of 2%.\nAssuming that you leave that money in the bank for several years, with a constant rate of return \\(r\\), you can use the Future Value (FV) formula to calculate how much money you’ll have at the end of year \\(n\\):\n\\[\n\\text{FV} = \\text{PV} (1 + r)^n\n\\]\nwhere:\n\n\\(\\text{FV}\\) = future value\n\\(\\text{PV}\\) = present value\n\\(\\text{r}\\) = annual interest rate\n\\(\\text{n}\\) = number of years\n\nHere’s some R code to obtain a vector amounts containing the amount of money that you would have from the beginning of time, and at the end of every year during a 5 year period:\n\n# inputs\ndeposit = 1000\nrate = 0.02\nyears = 0:5\n\n# future values\namounts = deposit * (1 + rate)^years\namounts\n\n[1] 1000.000 1020.000 1040.400 1061.208 1082.432\n[6] 1104.081\n\n\nRecall that this code is an example of vectorized (and recycling) code because the FV formula is applied to all the elements of the involved vectors, some of which have different lengths.\nSo far, so good.\nNow, consider a seemingly simple modification. What if you want to organize the amount values in a table? Something like this:\n\n\n\nyear\namount\n\n\n\n\n0\n1000.000\n\n\n1\n1020.000\n\n\n2\n1040.400\n\n\n3\n1061.208\n\n\n4\n1082.432\n\n\n5\n1104.081\n\n\n\nIn other words, what if you are interested not in getting the set of future values in a vector, but instead you want them to be arranged in some sort of tabular object? How can you create a table in which the first column year corresponds to the years, and the second column amount corresponds to the future amounts? Let’s find out."
  },
  {
    "objectID": "3-01-matrices-intro.html#matrices",
    "href": "3-01-matrices-intro.html#matrices",
    "title": "6  Matrices and Arrays",
    "section": "6.2 Matrices",
    "text": "6.2 Matrices\nR provides two main ways to organize data in a tabular (i.e. rectangular) object. One of them is a matrix—the topic of this chapter—and the other one is a data.frame—to be discussed in a subsequent chapter.\n\nCreating a matrix by column-binding vectors\nYou can build a matrix by column binding vectors using the function cbind(). In the code below we pass years and amount to the cbind() function, which returns a matrix having the tabular structure that we are looking for: years in the first column, and amounts in the second column.\n\n# inputs\ndeposit = 1000\nrate = 0.02\nyears = 0:5\n\n# future values\namounts = deposit * (1 + rate)^years\n\n# output as a matrix via cbind()\nsavings = cbind(years, amounts)\nsavings\n\n     years  amounts\n[1,]     0 1000.000\n[2,]     1 1020.000\n[3,]     2 1040.400\n[4,]     3 1061.208\n[5,]     4 1082.432\n[6,]     5 1104.081\n\n\nAs you can tell, the use of cbind() is straightforward. All you have to do is pass the vectors, separating them with a comma. Each vector will become a column of the returned matrix.\n\n\nCreating a matrix by row-binding vectors\nYou can also build a matrix by row binding vectors. For instance, pretend for a minute that we are interested in obtaining a tabular object in which the first row corresponds to years, and the second row to amounts. To obtain this object we use rbind() as follows:\n\nsavings = rbind(years, amounts)\nsavings\n\n        [,1] [,2]   [,3]     [,4]     [,5]\nyears      0    1    2.0    3.000    4.000\namounts 1000 1020 1040.4 1061.208 1082.432\n            [,6]\nyears      5.000\namounts 1104.081\n\n\nThe difference between cbind() and rbind() is that the latter will “stack” the given vectors on top of each other. That is, each vector will become a row of the returned matrix.\n\n\n6.2.1 What kind of object is a matrix?\nIn turns out that an R matrix is a special type of multi-dimensional atomic object called array. Both classes of objects, together with vectors and factors, form the triad of atomic objects. This is illustrated in the following diagram in terms of their number of dimensions.\n\n\n\n\n\nTriad of atomic data objects in R.\n\n\n\n\nPersonally, I prefer to reserve the term array for three or more dimensional arrays. As you can tell from the above diagram, this is how I’m using this term in the book. However, you should always keep in mind that a matrix is an array. The other way around is not necessarily true: not all arrays are matrices."
  },
  {
    "objectID": "3-01-matrices-intro.html#creating-matrices-with-matrix",
    "href": "3-01-matrices-intro.html#creating-matrices-with-matrix",
    "title": "6  Matrices and Arrays",
    "section": "6.3 Creating matrices with matrix()",
    "text": "6.3 Creating matrices with matrix()\nThe cbind() and rbind() functions provide a convenient way to create matrices from different input vectors. But the kind of matrices that you can create with them is limited if all you have is just one input vector.\nSo, in addition to cbind() and rbind(), R comes with the function matrix() which is the workhorse function for creating matrices. Usually, you provide an input vector, and also the number of rows and columns (i.e. the matrix dimensions) that the returned matrix should have.\nHere is how to use matrix() to create the savings matrix that we are interested in obtaining:\n\nsavings = matrix(c(years, amounts), nrow = 6, ncol = 2)\nsavings\n\n     [,1]     [,2]\n[1,]    0 1000.000\n[2,]    1 1020.000\n[3,]    2 1040.400\n[4,]    3 1061.208\n[5,]    4 1082.432\n[6,]    5 1104.081\n\n\nThis is an interesting piece of code. Notice that years and amounts are combined into a single vector, which is the main input of matrix(). The two other arguments correspond to the matrix dimensions: nrow = 6 tells R that we want to produce a matrix with 6 rows; ncol = 2 indicates that we want the matrix to have 2 columns.\n\n6.3.1 Column-Major Matrices\nWhen creating a matrix via the function matrix(), R takes into consideration three important aspects:\n\nthe length of the input vector.\nthe “size” of the matrix given by its number of rows and columns; think of this as the total number of cells or entries in the matrix.\nwhether the length of the input vector is a multiple or sub-multiple of the size of the matrix.\n\nIn the current example, the input vector c(years, amounts) has 12 elements. In turn, the size of the desired matrix is given by the multiplication of the number of rows (2) times the number of columns (6), that is:\n\\[\n\\text{size of matrix} = 6 \\times 2 = 12 \\text{ cells}\n\\]\nR then compares the length of the input vector against the size of the matrix. If these numbers are the same, like in this example, R proceeds to split the elements of the input vector into 2 sections or sub-vectors, each one containing 6 elements. Each of these sections will become a column of the output matrix.\nIn other words, the vector c(years, amounts) is split into 2 sub-vectors:\n# the first sub-vector is:\n0  1  2  3  4  5\n\n# the second sub-vector is:\n1000.000  1020.000  1040.400  1061.208  1082.432  1104.081\nThe first sub-vector, which corresponds to years, becomes the first column. The second sub-vector, which corresponds to amounts, becomes the second column. In technical terms we say that R matrices are stored column-major because of the mechanism used by R to arrange the elements of an input vector in order to create a matrix.\n\nMismatch between length of input vector and size of matrix\nWhat about those cases in which the length of the input vector does not match the size of the desired matrix? For example, consider the following commands illustrating this type of situation:\n\n# examples in which length of input vector\n# does not match size of matrix\nm1 = matrix(1:3, nrow = 3, ncol = 2)\n\nm2 = matrix(1:3, nrow = 2, ncol = 3)\n\nm3 = matrix(1:12, nrow = 3, ncol = 2)\n\nWarning in matrix(1:12, nrow = 3, ncol = 2): data\nlength differs from size of matrix: [12 != 3 x 2]\n\nm4 = matrix(1:4, nrow = 3, ncol = 2)\n\nWarning in matrix(1:4, nrow = 3, ncol = 2): data\nlength [4] is not a sub-multiple or multiple of\nthe number of rows [3]\n\nm5 = matrix(1:8, nrow = 2, ncol = 3)\n\nWarning in matrix(1:8, nrow = 2, ncol = 3): data\nlength [8] is not a sub-multiple or multiple of\nthe number of columns [3]\n\n\nIn matrices m1 and m2 the input vector 1:3 is a sub-multiple of the size of the matrix 6.\nIn matrix m3 the input vector 1:12 is longer than the size of the matrix: 6. However, the entire length of the vector, 12, is a multiple of the size 6.\nIn matrices m4 and m5, all the input vectors have lengths that are neither a multiple or sub-multiple of the size of the returned matrix.\nWhen the length of the input vector does not match the size of the desired matrix, R applies its recycling rules. Let’s pay attention to m1:\n\nm1\n\n     [,1] [,2]\n[1,]    1    1\n[2,]    2    2\n[3,]    3    3\n\n\nNote how the values of the input vector 1:3 are recycled to form the columns of m1. The values appear in the first column, but they also appear in the second column after being recycled.\nIn contrast, matrix m3 does not use all the elements in the input vector 1:12. Instead, only the first six values are retained.\nAs for the matrices m4 and m5, they all have an input vector whose length is neither a multiple nor a sub-multiple of the size of the matrix. In these cases R will also apply its recycling rules, but it will also display a warning message letting us know that the length of the input vector is not a multiple or sub-multiple of either the number of rows or the number of columns.\n\n\n\n6.3.2 Giving names to rows and columns\nOften, you may need to provide names for either the rows and/or the columns of a matrix. R comes with the functions rownames() and colnames() that can be used to assign names for the rows and columns, for example:\n\n# matrix of savings amounts\nsavings = matrix(c(years, amounts), nrow = 6, ncol = 2)\n\n# row and columns names\nrownames(savings) = 1:6\ncolnames(savings) = c(\"year\", \"amount\")\n\nsavings\n\n  year   amount\n1    0 1000.000\n2    1 1020.000\n3    2 1040.400\n4    3 1061.208\n5    4 1082.432\n6    5 1104.081\n\n\n\n\n6.3.3 More Matrices\nLet’s make things a bit more complex. Say you have the following investments:\n\n$1000 in a savings account that pays 2% annual return, during 4 years\n$2000 in a money market account that pays 2.5% annual return, during 2 years\n$5000 in a certificate of deposit that pays 3% annual return, during 3 years\n\nIn R, we can calculate the future values of each type of investment product:\n\n# savings account\nsavings = 1000 * (1 + 0.02)^(0:4)\nsavings\n\n[1] 1000.000 1020.000 1040.400 1061.208 1082.432\n\n\n\n# money market\nmoneymkt = 2000 * (1 + 0.025)^(0:2)\nmoneymkt\n\n[1] 2000.00 2050.00 2101.25\n\n\n\n# certificate of deposit\ncertificate = 5000 * (1 + 0.03)^(0:3)\ncertificate\n\n[1] 5000.000 5150.000 5304.500 5463.635\n\n\n\nSeparated matrices\nWe can create individual matrices for each type of account:\n\n# savings account\nsav_mat = cbind(0:4, savings)\n\n\n# money market\nmm_mat = cbind(0:2, moneymkt)\n\n\n# certificate of deposit\ncd_mat = cbind(0:3, certificate)\n\n\n\nSingle matrix\nAlternatively, we can stack everything into a single matrix:\n\ncbind(c(0:4, 0:2, 0:3), c(savings, moneymkt, certificate))\n\n      [,1]     [,2]\n [1,]    0 1000.000\n [2,]    1 1020.000\n [3,]    2 1040.400\n [4,]    3 1061.208\n [5,]    4 1082.432\n [6,]    0 2000.000\n [7,]    1 2050.000\n [8,]    2 2101.250\n [9,]    0 5000.000\n[10,]    1 5150.000\n[11,]    2 5304.500\n[12,]    3 5463.635\n\n\n\n\nWhat about mixing data types?\nWhat if you want some table like this:\n\n\n\naccount\nyear\namount\n\n\n\n\nsavings\n0\n1000.000\n\n\nsavings\n1\n1020.000\n\n\nsavings\n2\n1040.400\n\n\nsavings\n3\n1061.208\n\n\nsavings\n4\n1082.432\n\n\nmoneymkt\n0\n2000.000\n\n\nmoneymkt\n1\n2050.000\n\n\nmoneymkt\n2\n2101.250\n\n\ncertif\n0\n5000.000\n\n\ncertif\n1\n5150.250\n\n\ncertif\n2\n5304.500\n\n\ncertif\n3\n5463.635\n\n\n\nWe could use the cbind() function in an attempt to obtain a matrix having a similar rectangular structure as in the above table:\n\ninvestments = cbind(\n  rep(c(\"savings\", \"moneymkt\", \"certif\"), times = c(5, 3, 4)),\n  c(0:4, 0:2, 0:3), \n  c(savings, moneymkt, certificate))\n\ninvestments\n\n      [,1]       [,2] [,3]        \n [1,] \"savings\"  \"0\"  \"1000\"      \n [2,] \"savings\"  \"1\"  \"1020\"      \n [3,] \"savings\"  \"2\"  \"1040.4\"    \n [4,] \"savings\"  \"3\"  \"1061.208\"  \n [5,] \"savings\"  \"4\"  \"1082.43216\"\n [6,] \"moneymkt\" \"0\"  \"2000\"      \n [7,] \"moneymkt\" \"1\"  \"2050\"      \n [8,] \"moneymkt\" \"2\"  \"2101.25\"   \n [9,] \"certif\"   \"0\"  \"5000\"      \n[10,] \"certif\"   \"1\"  \"5150\"      \n[11,] \"certif\"   \"2\"  \"5304.5\"    \n[12,] \"certif\"   \"3\"  \"5463.635\"  \n\n\nDo you notice something funny with the matrix investments?\nAs you can tell, all the values in investments are displayed being surrounded with double quotes. This indicates that all the values are of type character. Why is this?\nRecall that matrices are atomic objects. Usually, you provide an input vector containing the elements to be arranged into a rectangular array with a certain number of rows and columns. Because vectors are atomic, this property is “inherited” by the returned matrix.\nIt turns out that you can use other classes of data objects, not necessarily atomic, for creating a matrix. If the input object is non-atomic, R will coerce it into a vector, making the input an atomic object.\nSo either way, whether you provide an atomic input or a non-atomic input, to any of the matrix-creation functions, R will always produce an atomic output. This is the reason why the below command produces a character matrix:\n\ninvestments = cbind(\n  rep(c(\"savings\", \"moneymkt\", \"certif\"), times = c(5, 3, 4)),\n  c(0:4, 0:2, 0:3), \n  c(savings, moneymkt, certificate))\n\ntypeof(investments)\n\n[1] \"character\"\n\n\nThe three input vectors are coerced into a single vector of character data type, causing the investments matrix to be of type character."
  },
  {
    "objectID": "3-01-matrices-intro.html#exercises",
    "href": "3-01-matrices-intro.html#exercises",
    "title": "6  Matrices and Arrays",
    "section": "6.4 Exercises",
    "text": "6.4 Exercises\n1) Use matrix() to create a matrix mat1 (see below) from the input vector x = letters[1:15]:\n# mat1\n\"a\"  \"d\"  \"g\"  \"j\"  \"m\" \n\"b\"  \"e\"  \"h\"  \"k\"  \"n\" \n\"c\"  \"f\"  \"i\"  \"l\"  \"o\"\n\n\nShow answer\nx = letters[1:15]\nmat1 = matrix(x, nrow = 3, ncol = 5)\n\n\n\n2) Look at the documentation of matrix() and find how to use it for obtaining the matrix mat2 (see below) from the input vector x = letters[1:15]:\n# mat2\n\"a\"  \"b\"  \"c\"  \"d\"  \"e\" \n\"f\"  \"g\"  \"h\"  \"i\"  \"j\" \n\"k\"  \"l\"  \"m\"  \"n\"  \"o\" \n\n\nShow answer\nx = letters[1:15]\nmat2 = matrix(x, nrow = 3, ncol = 5, byrow = TRUE)\n\n\n\n3) Find out how to use the functions rownames() and colnames() to give names to the rows and the columns of matrix mat1. Choose any names you want, and display matrix mat1.\n\n\nShow answer\nrownames(mat1) = c('r1', 'r2', 'r3')\ncolnames(mat1) = c('c1', 'c2', 'c3', 'c4', 'c5')\n\n\n\n4) Use matrix() to create a matrix mat3 (see below) from the input vector y = month.name:\n# mat3\n\"January\" \"February\" \"March\"    \n\"April\"   \"May\"      \"June\"     \n\"July\"    \"August\"   \"September\"\n\"October\" \"November\" \"December\" \n\n\nShow answer\ny = month.name\nmat3 = matrix(y, nrow = 4, ncol = 3, byrow = TRUE)\n\n\n\n5) Use matrix()—and its recycling principle—to create a matrix mat4 (see below) from the input vector a = c(3, 6, 9):\n# mat4\n3    3    3\n6    6    6\n9    9    9\n\n\nShow answer\na = c(3, 6, 9)\nmat4 = matrix(a, nrow = 3, ncol = 3)\n\n\n\n6) Use matrix()—and its recycling principle—to create a matrix mat5 (see below) from the input vector a = c(3, 6, 9):\n# mat5\n3    3    3\n6    6    6\n9    9    9\n3    3    3\n6    6    6\n9    9    9\n\n\nShow answer\na = c(3, 6, 9)\nmat5 = matrix(a, nrow = 6, ncol = 3)\n\n\n\n7) Consider the following vectors a and b\n\na = c(2, 4, 6)\nb = c(1, 3, 5)\n\nUse the row-binding function rbind(), with inputs a and b, to create a matrix mat6 displayed below:\n\n# mat6\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n\n\n\nShow answer\nmat6 = rbind(b, a)\n\n\n\n8) Consider the following vectors u and v\n\nu = c(2, 4, 6, 8)\nv = c(1, 3, 5, 7)\n\nUse the column-binding function cbind(), with inputs u and v, to create a matrix mat7 displayed below:\n\n# mat7\n\n     [,1] [,2] [,3]\n[1,]    2    1    2\n[2,]    4    3    4\n[3,]    6    5    6\n[4,]    8    7    8\n\n\n\n\nShow answer\nmat7 = cbind(u, v, u)\n\n\n\n9) Find out how to use the diag() function to create an identity matrix of dimensions 4 rows and 4 columns (see below). BTW: An identity matrix is a matrix with the same number of rows and columns, has ones in the diagonal, and zeroes off-diagonal.\n1    0    0    0\n0    1    0    0\n0    0    1    0\n0    0    0    1\n\n\nShow answer\ndiag(1, nrow = 4)\n\n\n\n10) Refer to matrices mat4 and mat7. Use both cbind() and rbind() to attempt binding these two matrices. If one of the binding operations fails, explain why.\n\n\nShow answer\n# cbind(mat4, mat7) fails because these matrices have different number of rows\n\n# rbind(mat4, mat7) works"
  },
  {
    "objectID": "3-02-matrices-operations.html",
    "href": "3-02-matrices-operations.html",
    "title": "7  More About Matrices",
    "section": "",
    "text": "Now that you have seen some ways to create matrices, let’s discuss a number of basic manipulations of matrices. I will show you examples of various operations, and then you’ll have the chance to put them in practice with some exercises listed at the end of the chapter."
  },
  {
    "objectID": "3-02-matrices-operations.html#basic-operations-with-matrices",
    "href": "3-02-matrices-operations.html#basic-operations-with-matrices",
    "title": "7  More About Matrices",
    "section": "7.1 Basic Operations with Matrices",
    "text": "7.1 Basic Operations with Matrices\n\nSelecting elements:\n\nselect a given cell\nselect a set of cells\nselect a given row\nselect a set of rows\nselect a given column\nselect a set of columns\n\nAdding a new column\nAdding a new row\nDeleting a column\nDeleting a row\nRenaming a column\nMoving a column\n\nLet’s say you have a matrix mat with the following content:\n\n# inputs\ndeposit = 1000\nrate_savings = 0.02\nrate_moneymkt = 0.025\nrate_certificate = 0.03\nyears = 0:5\n\n# future values\nsavings = deposit * (1 + rate_savings)^years\nmoneymkt = deposit * (1 + rate_moneymkt)^years\ncertificate = deposit * (1 + rate_certificate)^years\n\n# matrix\nmat = matrix(c(years, savings, moneymkt, certificate), nrow = 6, ncol = 4)\n\n# row and columns names\nrownames(mat) = 1:6\ncolnames(mat) = c(\"year\", \"savings\", \"moneymkt\", \"certificate\")\n\nmat\n\n  year  savings moneymkt certificate\n1    0 1000.000 1000.000    1000.000\n2    1 1020.000 1025.000    1030.000\n3    2 1040.400 1050.625    1060.900\n4    3 1061.208 1076.891    1092.727\n5    4 1082.432 1103.813    1125.509\n6    5 1104.081 1131.408    1159.274\n\n\n\n7.1.1 Selecting elements\nThe matrix mat is a 2-dimensional object: the 1st dimension corresponds to the rows, while the 2nd dimension corresponds to the columns. Because mat has two dimensions, the bracket notation involves working with data frames in this form: mat[ , ].\n\n\n\n\n\nBracket notation in matrices\n\n\n\n\nIn other words, you have to specify values inside the brackets for the 1st index, and the 2nd index: mat[index1, index2].\n\nSelecting cells\n\n\n\n\n\nSeveral ways to select cells\n\n\n\n\n\n# select value in row 1 and column 1\nmat[1, 1]\n\n[1] 0\n\n# select value in row 2 and column 3\nmat[2, 3]\n\n[1] 1025\n\n# select values in these cells\nmat[1:2, 3:4]\n\n  moneymkt certificate\n1     1000        1000\n2     1025        1030\n\n\nIt is also possible to exclude certain rows-and-columns by passing negative numeric indices:\n\n\n\n\n\nSeveral ways to exclude cells\n\n\n\n\n\n\nSelecting rows\n\n\n\n\n\nSeveral ways to select rows\n\n\n\n\nIf no value is specified for index1 then all rows are included. Likewise, if no value is specified for index2 then all columns are included.\n\n# selecting first row\nmat[1, ]\n\n       year     savings    moneymkt certificate \n          0        1000        1000        1000 \n\n# selecting third row\nmat[3, ]\n\n       year     savings    moneymkt certificate \n      2.000    1040.400    1050.625    1060.900 \n\n\n\n\n\n\n\nSeveral ways to exclude rows\n\n\n\n\n\n\nSelecting columns\n\n\n\n\n\nSeveral ways to select columns\n\n\n\n\n\n# selecting second column\nmat[ ,2]\n\n       1        2        3        4        5        6 \n1000.000 1020.000 1040.400 1061.208 1082.432 1104.081 \n\n# selecting columns 2 to 4\nmat[ ,2:4]\n\n   savings moneymkt certificate\n1 1000.000 1000.000    1000.000\n2 1020.000 1025.000    1030.000\n3 1040.400 1050.625    1060.900\n4 1061.208 1076.891    1092.727\n5 1082.432 1103.813    1125.509\n6 1104.081 1131.408    1159.274\n\n\n\n\n\n\n\nSeveral ways to exclude columns\n\n\n\n\n\n\n\n7.1.2 Adding a column\nTo add a column, use the column-bind function cbind()\n\n# vector\nvec <- c(2, 4, 6, 8, 10, 12)\n\n# adding weights to mat\nmat <- cbind(mat, vec)\nmat\n\n  year  savings moneymkt certificate vec\n1    0 1000.000 1000.000    1000.000   2\n2    1 1020.000 1025.000    1030.000   4\n3    2 1040.400 1050.625    1060.900   6\n4    3 1061.208 1076.891    1092.727   8\n5    4 1082.432 1103.813    1125.509  10\n6    5 1104.081 1131.408    1159.274  12\n\n\n\n\n7.1.3 Deleting a column\nWhat if you want to delete a column? Simple: use a negative index to exclude the undesired column(s)\n\n# deleting fifth column\nmat <- mat[ ,-5]\nmat\n\n  year  savings moneymkt certificate\n1    0 1000.000 1000.000    1000.000\n2    1 1020.000 1025.000    1030.000\n3    2 1040.400 1050.625    1060.900\n4    3 1061.208 1076.891    1092.727\n5    4 1082.432 1103.813    1125.509\n6    5 1104.081 1131.408    1159.274\n\n\n\n\n7.1.4 Moving a column\nWhat if you want to move one or more columns to a different position? For example, what if you want to move year to the last position (last column)? One option is to create a vector of column indices in the desired order, and then use this vector (for the index of columns) to reassign the matrix like this:\n\nreordered_cols <- c(2:4, 1)\nmat <- mat[ ,reordered_cols]\nmat\n\n   savings moneymkt certificate year\n1 1000.000 1000.000    1000.000    0\n2 1020.000 1025.000    1030.000    1\n3 1040.400 1050.625    1060.900    2\n4 1061.208 1076.891    1092.727    3\n5 1082.432 1103.813    1125.509    4\n6 1104.081 1131.408    1159.274    5"
  },
  {
    "objectID": "4-01-lists.html",
    "href": "4-01-lists.html",
    "title": "8  Lists",
    "section": "",
    "text": "In this chapter, you will learn about R lists, the most generic type of data container in R. Here’s a summary of the main features of R lists:"
  },
  {
    "objectID": "4-01-lists.html#motivation",
    "href": "4-01-lists.html#motivation",
    "title": "8  Lists",
    "section": "8.1 Motivation",
    "text": "8.1 Motivation\nIn the chapter about Matrices and Arrays we considered a small portfolio consisting of the following three investments:\n\n$1000 in a savings account that pays 2% annual return, during 4 years\n$2000 in a money market account that pays 2.5% annual return, during 2 years\n$5000 in a certificate of deposit that pays 3% annual return, during 3 years\n\nLet’s pay attention to the first investment: the savings account. Suppose I’m interested in creating an object to store the specifications of this investment, that is, I would like to have an R object with four elements\n\nthe initial deposit: 1000\nthe annual rate of return: 0.02\nthe number of years: 4L\nand the type of account: \"savings\"\n\nWhat kind of object could I use? With all the things we’ve discussed so far, a natural decision would be to store these values in a vector:\n\ninvestment1_specs = c(\n  \"deposit\" = 1000,      # double\n  \"rate\" = 0.02,         # double\n  \"years\" = 4L,          # integer\n  \"account\" = \"savings\"  # character\n)\n\nNotice that I’m creating investment1_specs by mixing elements of different data types: a couple of double types, an integer type, and a character type. Thus, a very pertinent question is: What kind of vector is investment1_specs? If your answer to the preceding question was character, then congrats! By now, I expect that you can correctly answer this question without any trouble. If that is not the case then go back to chapter Creating Vectors and reread the section on Coercion.\nOne simple way to confirm that investment1_specs is indeed of \"character\" type is by simply inspecting its contents:\n\ninvestment1_specs\n\n  deposit      rate     years   account \n   \"1000\"    \"0.02\"       \"4\" \"savings\" \n\n\nWhile the investment1_specs object “technically” is storing the specifications of the savings account, all the initial numeric values have been coerced into characters, which may not be the best way to store this information. The solution to this limitation that vectors and other atomic objects have is to employ another kind of object in R: lists."
  },
  {
    "objectID": "4-01-lists.html#lists",
    "href": "4-01-lists.html#lists",
    "title": "8  Lists",
    "section": "8.2 Lists",
    "text": "8.2 Lists\nAn R list is the most generic kind of data object in R in the sense that you can combine elements of different data types without them being coerced.\nThe primary function to create lists is the homonym function list(). To give you an example of a basic list let us again pay attention to the specifications of the first investment\n\nthe initial deposit: 1000\nthe annual rate of return: 0.02\nthe number of years: 4L\nand the type of account: \"savings\"\n\nInstead of using a vector, we can create a list to store these values. All we have to do is use list() instead of c():\n\nspecs1 = list(\n  \"deposit\" = 1000,      # double\n  \"rate\" = 0.02,         # double\n  \"years\" = 4L,          # integer\n  \"account\" = \"savings\"  # character\n)\n\nspecs1\n\n$deposit\n[1] 1000\n\n$rate\n[1] 0.02\n\n$years\n[1] 4\n\n$account\n[1] \"savings\"\n\n\nObserve the way R prints a list with named elements. In contrast to the way elements of a vector are displayed—in a contiguous form—the elements of a list are displayed in a noncontiguous manner. Also, note how the names of the elements are listed with a preappended dollar sign. For example, the first element is $deposit, the second element is $rate, and so on.\nWhat about the data type for each element of the list? From the visual inspection of the elements in specs1, you can tell that all the numeric values are not being coerced into strings. Which is what we were looking for. We were interested in obtaining an object in which each of its elements gets to keep its data type.\nIf you try to use typeof() on a list in an attempt to get the data types of its elements, I’m afraid this won’t work the way you expect it:\n\ntypeof(specs1)\n\n[1] \"list\"\n\n\nApplying typeof() on a list results in a not very interesting output \"list\".\nGetting ahead of myself momentarily, let me show you how to use the dollar operator $ to refer to an named element of a list and check its data type:\n\ntypeof(specs1$deposit)\n\n[1] \"double\"\n\ntypeof(specs1$account)\n\n[1] \"character\"\n\n\nWe’ll discuss the different ways in which you can subset elements of a list later in this chapter."
  },
  {
    "objectID": "4-01-lists.html#creating-lists",
    "href": "4-01-lists.html#creating-lists",
    "title": "8  Lists",
    "section": "8.3 Creating Lists",
    "text": "8.3 Creating Lists\nThe typical way to create a list is with the function list(). This function creates a list the same way c() creates a vector. Let’s start with a simple example creating three numeric vectors of same length, that we then use to store them in a list:\n\nvec1 <- 1:3\nvec2 <- 4:6\nvec3 <- 7:9\n\n# list with unnamed elements\nlis <- list(vec1, vec2, vec3)\nlis\n\n[[1]]\n[1] 1 2 3\n\n[[2]]\n[1] 4 5 6\n\n[[3]]\n[1] 7 8 9\n\n\nNote how the contents of a list with unnamed elements are displayed: there is a set of double brackets with an index indicating the position of each element, and below each double bracket the corresponding vector is printed.\nFor illustration purposes, we could visualize the three input vectors and the list with the following conceptual diagram.\n\n\n\n\n\nA list containing three unnamed elements (numeric vectors of length 3)\n\n\n\n\nOur intention with the depicted list as a set of discontinuous cells is to convey the idea that a list is also a one-dimensional vector, albeit a very special type of vector: a non-atomic vector. This means that each element of a list can be any kind of object.\nIn the same way you can give names to elements of a vector, you can also give names to elements of a list:\n\n# list with named elements\nlis <- list(\"vec1\" = vec1, \"vec2\" = vec2, \"vec3\" = vec3)\nlis\n\n$vec1\n[1] 1 2 3\n\n$vec2\n[1] 4 5 6\n\n$vec3\n[1] 7 8 9\n\n\nWhen you create a list in this form, you can actually omit the quotes of the given names. While this option of naming elements may create a bit of confusion for beginners and inexperienced users in R, we believe it’s not a big deal (based on our experience):\n\n# another option for giving names to elements in a list\nlis <- list(vec1 = vec1, vec2 = vec2, vec3 = vec3)\nlis\n\n$vec1\n[1] 1 2 3\n\n$vec2\n[1] 4 5 6\n\n$vec3\n[1] 7 8 9\n\n\nObserve how the contents of a list with named elements are displayed: this time, instead of the set of double brackets, there is a dollar sign followed by the name of the element, e.g. $vec1. Below each name, the corresponding vector is printed.\nThe conceptual diagram in this case could look like this:\n\n\n\n\n\nA list with named elements (numeric vectors of length 3)\n\n\n\n\nAs we just said, the elements of a list can be any kind of R object. For example, here’s a list called lst that contains a character vector, a numeric matrix, a factor, and another list:\n\nlst <- list(\n  c(\"savings\", \"money_mkt\", \"certificate\"),\n  matrix(1:6, nrow = 2, ncol = 3),\n  factor(c(\"yes\", \"no\", \"no\", \"no\", \"yes\")),\n  list(1000, 2000, 5000)\n)\n\nlst\n\n[[1]]\n[1] \"savings\"     \"money_mkt\"   \"certificate\"\n\n[[2]]\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n[[3]]\n[1] yes no  no  no  yes\nLevels: no yes\n\n[[4]]\n[[4]][[1]]\n[1] 1000\n\n[[4]][[2]]\n[1] 2000\n\n[[4]][[3]]\n[1] 5000\n\n\nWhenever possible, I strongly recommend giving names to the elements of a list. Not only this makes it easy to identify one element from the others, but it also gives you more flexibility to rearrange the contents of the list without having to worry about the exact order or position they occupy.\n\n# whenever possible, give names to elements in a list\nlst <- list(\n  first = c(\"savings\", \"money_mkt\", \"certificate\"),\n  second = matrix(1:6, nrow = 2, ncol = 3),\n  third = factor(c(\"yes\", \"no\", \"no\", \"no\", \"yes\")),\n  fourth = list(1000, 2000, 5000)\n)"
  },
  {
    "objectID": "4-01-lists.html#manipulating-lists",
    "href": "4-01-lists.html#manipulating-lists",
    "title": "8  Lists",
    "section": "8.4 Manipulating Lists",
    "text": "8.4 Manipulating Lists\nTo manipulate the elements of a list you can use bracket notation. Because a list is a vector, you can use single brackets (e.g. lis[1]) as well as double brackets (e.g. lis[[1]]).\n\n\n\n\n\nBracket notation with lists\n\n\n\n\n\n8.4.1 Single brackets\nJust like any other vector, and any other data object in R, you can use single brackets on a list. For example, consider the unnamed version of a list, and the use of single brackets with index 1 inside them:\n\n# list with unnamed elements\nlis <- list(vec1, vec2, vec3)\n\nlis[1]\n\n[[1]]\n[1] 1 2 3\n\n\nWhat a single bracket does, is give you access to the “container” of the specified element but without “unboxing” its contents. This is reflected by the way in which the output is displayed: note the double bracket [[1]] in the first line, and then [1] 1 2 3 in the second line.\nIn other words, lis[1] gives you the first element of the list, which contains a vector, but it does not give you direct access to the vector itself. Put another way, lis[1] lets you see that the first element of the list is a vector, but this vector is still inside its “box”.\n\n\n\n\n\nUse single brackets to select an element\n\n\n\n\n\n\n8.4.2 Double Brackets\nIn addition to single brackets, lists also accept double brackets: e.g.  lis[[1]]\n\nlis[[1]]\n\n[1] 1 2 3\n\n\nDouble brackets are used when you want to get access to the content of the list’s elements. Notice the output of the previous command: now there are no double brackets, just the output of the vector in the first position. Think of this command as “unboxing” the object of the first element in lis.\nWhat if you want to manipulate the elements of vector vec1 or vec2? Use double brackets followed by single brackets\n\n# second index of first list's element\nlis[[1]][2]\n\n[1] 2\n\n# first index of second list's element\nlis[[2]][1]\n\n[1] 4\n\n\n\n\n\n\n\nUse double brackets to extract an element\n\n\n\n\n\n\n8.4.3 Dollar signs\nR lists—and data frames—follow an optional second system of notation for extracting named elements using the dollar sign $\n\n\n\n\n\nDollar notation with lists\n\n\n\n\nLet’s use the named version of lis:\n\n# list with named elements\nlis <- list(\"vec1\" = vec1, \"vec2\" = vec2, \"vec3\" = vec3)\n\nlis$vec1\n\n[1] 1 2 3\n\n\nThe dollar sign $ notation works for selecting named elements in a list. Notice the output of the above command: lis$vec1 gives you vector 1 2 3. In other words, dollar notation “unboxes” the object that is associated to the specified name.\n\n\n8.4.4 Adding new elements\nFrom time to time, you will want to add one or more elements to an existing list. For instance, consider a list lst with two elements:\n\nlst <- list(1:3, c('A', 'B', 'C'))\n\nlst\n\n[[1]]\n[1] 1 2 3\n\n[[2]]\n[1] \"A\" \"B\" \"C\"\n\n\nSay you want to add a logical vector as a third element to lst. One option to do this is with double brackets, specifying a new index position to which you assign the new element:\n\nlst[[3]] <- c(TRUE, FALSE, TRUE, FALSE)\n\nlst\n\n[[1]]\n[1] 1 2 3\n\n[[2]]\n[1] \"A\" \"B\" \"C\"\n\n[[3]]\n[1]  TRUE FALSE  TRUE FALSE\n\n\nAnother option is to use the dollar operator by giving a new name to which you assign the new element. Even though the previous elements in lstare unnamed, the new added element will have an associated label:\n\nlst$new_elem <- 'nuevo'\n\nlst\n\n[[1]]\n[1] 1 2 3\n\n[[2]]\n[1] \"A\" \"B\" \"C\"\n\n[[3]]\n[1]  TRUE FALSE  TRUE FALSE\n\n$new_elem\n[1] \"nuevo\"\n\n\n\n\n8.4.5 Removing elements\nJust like you will want to add new elements in a list, you will also find occasions in which you need to remove one or more elements. Take the previous list lst with four elements, and say you want to remove the third element (containing the logical vector)\n\nlst\n\n[[1]]\n[1] 1 2 3\n\n[[2]]\n[1] \"A\" \"B\" \"C\"\n\n[[3]]\n[1]  TRUE FALSE  TRUE FALSE\n\n$new_elem\n[1] \"nuevo\"\n\n\nTo remove the third element, which is unnamed, you use double brackets and assign a value NULL to that position:\n\nlst[[3]] <- NULL\nlst\n\n[[1]]\n[1] 1 2 3\n\n[[2]]\n[1] \"A\" \"B\" \"C\"\n\n$new_elem\n[1] \"nuevo\"\n\n\nAs for those named elements, such as lst$new_elem, you do the same and assign a NULL value, but this time using dollar notation:\n\nlst$new_elem <- NULL\nlst\n\n[[1]]\n[1] 1 2 3\n\n[[2]]\n[1] \"A\" \"B\" \"C\""
  },
  {
    "objectID": "4-01-lists.html#exercises",
    "href": "4-01-lists.html#exercises",
    "title": "8  Lists",
    "section": "8.5 Exercises",
    "text": "8.5 Exercises\n1) How would you create a list with your first name, middle name, and last name? For example, something like:\n\n\n$first\n[1] \"Gaston\"\n\n$middle\nNULL\n\n$last\n[1] \"Sanchez\"\n\n\n\n\nShow answer\nlis = list(\n  first = \"Gaston\",\n  middle = NULL,\n  last = \"Sanchez\"\n)\n\n\n\n2) Consider an R list student containing the following elements:\n\n\n$name\n[1] \"Luke Skywalker\"\n\n$gpa\n[1] 3.8\n\n$major_minor\n              major               minor \n     \"jedi studies\" \"galactic policies\" \n\n$grades\n        course letter\n1 light-sabers      B\n2    force-101      A\n3  jedi-poetry     C+\n\n\n\nWhich of the following commands gives you the values of column letter (i.e. column of element grades)? Mark all valid options.\n\nstudent$grades[ ,letter]\nstudent$grades[ ,2]\nstudent[[4]][ ,2]\nstudent[4][ ,2]\n\n\n\n\nShow answer\n# a) values in column \"letter\" are given by:\n# option ii)\n# option iii)\n\n\n\nWhich of the following commands gives you the length of major_minor? Mark all valid options.\n\nlength(student[3])\nlength(student$major_minor)\nlength(student[c(FALSE, FALSE, TRUE, FALSE)])\nlength(student[[3]])\n\n\n\n\nShow answer\n# b) length of \"major_minor\" is given by:\n# option ii)\n# option iv)\n\n\n\nWhich of the following commands gives you the number of rows in grades? Mark all the valid options.\n\nnrow(student[[\"grades\"]])\nnrow(student[4])\nnrow(student$grades)\nnrow(student[ ,c(\"course\", \"letter\")])\n\n\n\n\nShow answer\n# c) values in column \"score\" are given by:\n# option i)\n# option iii)\n\n\n\nWhich of the following commands gives you the value in name? Mark all the valid options.\n\nstudent(1)\nstudent$name\nstudent[[name]]\nstudent[[-c(1,2,3)]]\n\n\n\n\nShow answer\n# d) value in \"name\" is given by:\n# option ii)\n# option iv)\n\n\n\n3) I have created an R object called obj, which looks like this when printed on the console:\n\n\n$exams\nmidterm   final \n    100      90 \nLevels: 90 100\n\n$grades\nmidterm   final \n   \"A+\"    \"A-\" \n\n$hws\n  topic points\n1     x    151\n2     y    154\n3     z    159\n\n\nIndicate whether each of the following statements is True or False.\n\nlength of obj$hws is 3\n\n\n\nShow answer\n# a) length of obj$hws is 3\n# False\n\n\n\ndata type of obj$exams could be double (i.e. real)\n\n\n\nShow answer\n# b) data type of obj$exams could be double\n# False\n\n\n\nobj$grades cannot be a factor\n\n\n\nShow answer\n# c) obj$grades cannot be a factor\n# True\n\n\n\nobj$hws could be a data frame\n\n\n\nShow answer\n# d) obj$hws could be a data frame  \n# True\n\n\n\nobj$hws could be a matrix\n\n\n\nShow answer\n# e) obj$hws could be a data frame  \n# False\n\n\n\ncolumn points in obj$hws could be a factor\n\n\n\nShow answer\n# f) column \"points\" in obj$hws could be a factor  \n# True\n\n\n\n4) Consider an R list apprentice containing the following elements:\n\n\n\n\n\n$name\n[1] \"Anakin Skywalker\"\n\n$gpa\n[1] 4\n\n$major_minor\n             major1              major2               minor \n     \"jedi studies\"      \"sith studies\" \"galactic policies\" \n\n$grades\n        course score\n1    force-101   9.3\n2    podracing  10.0\n3 light-sabers   8.5\n\n\nWithout running the commands in R, write down what will appear at the console when such commands are executed:\n\nlength(apprentice$major_minor)\n\n\n\n\n\napprentice$gpa < 2.5\n\n\n\n\n\nnames(apprentice$major_minor)\n\n\n\n\n\nrep(apprentice$grades[[2]][2], apprentice$gpa)\n\n\n\n\n\napprentice$grades[order(apprentice$grades$score), ]"
  },
  {
    "objectID": "4-02-data-frames.html",
    "href": "4-02-data-frames.html",
    "title": "9  Data Frames",
    "section": "",
    "text": "The most common format/structure for a data set is a tabular format: with rows and columns (like a spreadsheet). When your data is in this shape, most of the time you will work with R data frames (or similar rectangular structures like a \"matrix\", \"table\", \"tibble\", etc).\nLearning how to manipulate data frames is among the most important data computing skills in R. Nowadays, there are two primary approaches for manipulating data frames. One is what I call the “traditional” or “classic” approach which is what I present in this chapter. The other is the “tidy” approach which you can think of as a modern version based on the tidy data framework mainly developed by Hadley Wickham. We leave the discussion of this alternative approach for later.\nTo make the most of the content covered in the next sections, I am assuming that you are familiar with the rest of data objects covered in the previous chapters of part “II Data Objects in R”."
  },
  {
    "objectID": "4-02-data-frames.html#r-data-frames",
    "href": "4-02-data-frames.html#r-data-frames",
    "title": "9  Data Frames",
    "section": "9.1 R Data Frames",
    "text": "9.1 R Data Frames\nA data frame is a special type of R list. In most cases, a data frame is internally stored as a list of vectors or factors, in which each vector (or factor) corresponds to a column. This implies that columns in a data frame are typically atomic structures: all elements in a given column are of the same data type. However, since a data frame is a list, you can technically have any kind of object as a column. In practice, though, having data frames with columns that are not vectors or factors is something that does not make much sense.\n\n\n\n\n\nAbstract view of a data.frame\n\n\n\n\nFrom the data manipulation point of view, data frames behave like a hybrid object. On one hand, they are lists and can be manipulated like any other list using double brackets dat[[ ]] and dollar operator dat$name. On the other hand, because data frames are designed as tabular or 2-dimensional objects, they also behave like two-dimensional arrays or matrices, admitting bracket notation dat[ , ]. For these reasons, there is a wide array of functions that allows you to manipulate data frames in very convenient ways. But to the inexperienced user, all these functions may feel overwhelming."
  },
  {
    "objectID": "4-02-data-frames.html#inspecting-data-frames",
    "href": "4-02-data-frames.html#inspecting-data-frames",
    "title": "9  Data Frames",
    "section": "9.2 Inspecting data frames",
    "text": "9.2 Inspecting data frames\nOne of the basic tasks when working with data frames involves inspecting its contents. Specially in the early stages of data exploration, when dealing for the first time with a new data frame, you will need to inspect things like its overall structure, which includes its dimensions (number of rows and columns), the data types of its columns, the names of columns and rows, and also be able to take a peak to some of its first or last rows, and usually obtain a summary of each column.\nLet’s see an example with one of the built-in data frames in R: mtcars. Just a few rows and columns of mtcars are displayed below:\n\n\n                   mpg cyl disp  hp drat    wt\nMazda RX4         21.0   6  160 110 3.90 2.620\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875\nDatsun 710        22.8   4  108  93 3.85 2.320\nHornet 4 Drive    21.4   6  258 110 3.08 3.215\nHornet Sportabout 18.7   8  360 175 3.15 3.440\n\n\nThe main function to explore the structure of not just a data frame, but of any kind of object, is str(). When applied to data frames, str() returns a report of the dimensions of the data frame, a list with the name of all the variables, and their data types (e.g. chr character, num real, etc).\n\nstr(mtcars, vec.len = 1)\n\n'data.frame':   32 obs. of  11 variables:\n $ mpg : num  21 21 ...\n $ cyl : num  6 6 ...\n $ disp: num  160 160 ...\n $ hp  : num  110 110 ...\n $ drat: num  3.9 3.9 ...\n $ wt  : num  2.62 ...\n $ qsec: num  16.5 ...\n $ vs  : num  0 0 ...\n $ am  : num  1 1 ...\n $ gear: num  4 4 ...\n $ carb: num  4 4 ...\n\n\nThe argument vec.len = 1 is optional but we like to use it because it indicates that just the first elements in each column should be displayed. Observe the output returned by str(). The first line tells us that mtcars is an object of class 'data.frame' with 32 observations (rows) and 11 variables (columns). Then, the set of 11 variables is listed below, each line starting with the dollar $ operator, followed by the name of the variable, followed by a colon :, the data mode (all numeric num variables in this case), and then a couple of values in each variable.\nIt is specially useful to check the data type of each column in order to catch potential issues and avoid disastrous consequences or bugs in subsequent stages.\nHere’s a list of useful functions to inspect a data frame:\n\nstr(): overall structure\nhead(): first rows\ntail(): last rows\nsummary(): descriptive statistics\ndim(): dimensions\nnrow(): number of rows\nncol(): number of columns\nnames(): names of list elements (i.e. column names)\ncolnames(): column names\nrownames(): row names\ndimnames(): list with column and row names\n\nOn a technical side, we should mention that a data frame is a list with special attributes: an attribute names for column names, an attribute row.names for row names, and of course its attribute class:\n\nattributes(mtcars)\n\n$names\n [1] \"mpg\"  \"cyl\"  \"disp\" \"hp\"   \"drat\" \"wt\"   \"qsec\" \"vs\"   \"am\"   \"gear\"\n[11] \"carb\"\n\n$row.names\n [1] \"Mazda RX4\"           \"Mazda RX4 Wag\"       \"Datsun 710\"         \n [4] \"Hornet 4 Drive\"      \"Hornet Sportabout\"   \"Valiant\"            \n [7] \"Duster 360\"          \"Merc 240D\"           \"Merc 230\"           \n[10] \"Merc 280\"            \"Merc 280C\"           \"Merc 450SE\"         \n[13] \"Merc 450SL\"          \"Merc 450SLC\"         \"Cadillac Fleetwood\" \n[16] \"Lincoln Continental\" \"Chrysler Imperial\"   \"Fiat 128\"           \n[19] \"Honda Civic\"         \"Toyota Corolla\"      \"Toyota Corona\"      \n[22] \"Dodge Challenger\"    \"AMC Javelin\"         \"Camaro Z28\"         \n[25] \"Pontiac Firebird\"    \"Fiat X1-9\"           \"Porsche 914-2\"      \n[28] \"Lotus Europa\"        \"Ford Pantera L\"      \"Ferrari Dino\"       \n[31] \"Maserati Bora\"       \"Volvo 142E\"         \n\n$class\n[1] \"data.frame\""
  },
  {
    "objectID": "4-02-data-frames.html#creating-data-frames",
    "href": "4-02-data-frames.html#creating-data-frames",
    "title": "9  Data Frames",
    "section": "9.3 Creating data frames",
    "text": "9.3 Creating data frames\nMost of the (raw) data tables you will be working with will already be in some data file. However, from time to time you will face the need to create some sort of data table in R. In these situations, you will likely have to create such table with a data frame. So let’s look at various ways to “manually”” create a data frame.\nOption 1: The primary option to build a data frame is with data.frame(). You pass a series of vectors (or factors), of the same length, separated by commas. Each vector (or factor) will become a column in the generated data frame. Preferably, give names to each column like in the example below:\n\ndat <- data.frame(\n  name = c('Anakin', 'Padme', 'Luke', 'Leia'),\n  gender = c('male', 'female', 'male', 'female'),\n  height = c(1.88, 1.65, 1.72, 1.50),\n  weight = c(84, 45, 77, 49)\n) \n\ndat\n\n    name gender height weight\n1 Anakin   male   1.88     84\n2  Padme female   1.65     45\n3   Luke   male   1.72     77\n4   Leia female   1.50     49\n\n\nOption 2: Another way to create data frames is with a list containing vectors or factors (of the same length), which you then convert into a data frame with data.frame():\n\n# another way to create a basic data frame\nlst <- list(\n  name = c('Anakin', 'Padme', 'Luke', 'Leia'),\n  gender = c('male', 'female', 'male', 'female'),\n  height = c(1.88, 1.65, 1.72, 1.50),\n  weight = c(84, 45, 77, 49)\n)\n\ntbl <- data.frame(lst)\n\ntbl\n\n    name gender height weight\n1 Anakin   male   1.88     84\n2  Padme female   1.65     45\n3   Luke   male   1.72     77\n4   Leia female   1.50     49\n\n\nRemember that a data.frame is nothing more than a list. So as long as the elements in the list (vectors or factors) are of the same length, we can simply convert the list into a data frame.\nKeep in mind that in old versions of R (3.1.0 or older), data.frame() used to convert character vectors into factors. You can always check the data type of each column in a data frame with str():\n\nstr(tbl)\n\n'data.frame':   4 obs. of  4 variables:\n $ name  : chr  \"Anakin\" \"Padme\" \"Luke\" \"Leia\"\n $ gender: chr  \"male\" \"female\" \"male\" \"female\"\n $ height: num  1.88 1.65 1.72 1.5\n $ weight: num  84 45 77 49\n\n\nIn old versions of R, to prevent data.frame() from converting strings into factors, you had to use the argument stringsAsFactors = FALSE\n\n# strings as strings, not as factors\n# (for R ver 3.1.0 or older)\ndat <- data.frame(\n  name = c('Anakin', 'Padme', 'Luke', 'Leia'),\n  gender = c('male', 'female', 'male', 'female'),\n  height = c(1.88, 1.65, 1.72, 1.50),\n  weight = c(84, 45, 77, 49),\n  stringsAsFactors = FALSE\n)\n\nstr(dat)\n\n'data.frame':   4 obs. of  4 variables:\n $ name  : chr  \"Anakin\" \"Padme\" \"Luke\" \"Leia\"\n $ gender: chr  \"male\" \"female\" \"male\" \"female\"\n $ height: num  1.88 1.65 1.72 1.5\n $ weight: num  84 45 77 49"
  },
  {
    "objectID": "4-02-data-frames.html#basic-operations-with-data-frames",
    "href": "4-02-data-frames.html#basic-operations-with-data-frames",
    "title": "9  Data Frames",
    "section": "9.4 Basic Operations with Data Frames",
    "text": "9.4 Basic Operations with Data Frames\nNow that you have seen some ways to create data frames, let’s discuss a number of basic manipulations of data frames. We will show you examples of various operations, and then you’ll have the chance to put them in practice with some exercises listed at the end of the chapter.\n\nSelecting table elements:\n\nselect a given cell\nselect a set of cells\nselect a given row\nselect a set of rows\nselect a given column\nselect a set of columns\n\nAdding a new column\nDeleting a column\nRenaming a column\nMoving a column\nTransforming a column\n\nLet’s say you have a data frame dat with the following content:\n\ndat <- data.frame(\n  name = c('Leia', 'Luke', 'Han'),\n  gender = c('female', 'male', 'male'),\n  height = c(1.50, 1.72, 1.80),\n  jedi = c(FALSE, TRUE, FALSE),\n  stringsAsFactors = FALSE\n)\n\ndat\n\n  name gender height  jedi\n1 Leia female   1.50 FALSE\n2 Luke   male   1.72  TRUE\n3  Han   male   1.80 FALSE\n\n\n\n9.4.1 Selecting elements\nThe data frame dat is a 2-dimensional object: the 1st dimension corresponds to the rows, while the 2nd dimension corresponds to the columns. Because dat has two dimensions, the bracket notation involves working with data frames in this form: dat[ , ].\n\n\n\n\n\nBracket notation in data frames\n\n\n\n\nIn other words, you have to specify values inside the brackets for the 1st index, and the 2nd index: dat[index1, index2].\n\nSelecting cells\n\n\n\n\n\nSeveral ways to select cells\n\n\n\n\n\n# select value in row 1 and column 1\ndat[1,1]\n\n[1] \"Leia\"\n\n# select value in row 2 and column 3\ndat[2,3]\n\n[1] 1.72\n\n# select values in these cells\ndat[1:2,3:4]\n\n  height  jedi\n1   1.50 FALSE\n2   1.72  TRUE\n\n\nIt is also possible to exclude certain rows-and-columns by passing negative numeric indices:\n\n\n\n\n\nSeveral ways to exclude cells\n\n\n\n\n\n\nSelecting rows\n\n\n\n\n\nSeveral ways to select rows\n\n\n\n\nIf no value is specified for index1 then all rows are included. Likewise, if no value is specified for index2 then all columns are included.\n\n# selecting first row\ndat[1, ]\n\n  name gender height  jedi\n1 Leia female    1.5 FALSE\n\n# selecting third row\ndat[3, ]\n\n  name gender height  jedi\n3  Han   male    1.8 FALSE\n\n\n\n\n\n\n\nSeveral ways to exclude rows\n\n\n\n\n\n\nSelecting columns\n\n\n\n\n\nSeveral ways to select columns\n\n\n\n\n\n# selecting second column\ndat[ ,2]\n\n[1] \"female\" \"male\"   \"male\"  \n\n# selecting columns 2 to 4\ndat[ ,2:4]\n\n  gender height  jedi\n1 female   1.50 FALSE\n2   male   1.72  TRUE\n3   male   1.80 FALSE\n\n\n\n\n\n\n\nSeveral ways to exclude columns\n\n\n\n\n\n\nMore Options to Access Columns\n\n\n\n\n\nOther options to select columns of a data frame\n\n\n\n\nThe dollar sign also works for selecting a column of a data frame using its name\n\nmtcars$mpg\n\n [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4\n[16] 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7\n[31] 15.0 21.4\n\n\nYou don’t need to use quote marks, but you can if you want. The following calls are equivalent.\nmtcars$'mpg'\nmtcars$\"mpg\"\nmtcars$`mpg`\n\n\n\n9.4.2 Adding a column\nPerhaps the simplest way to add a column is with the dollar operator $. You just need to give a name for the new column, and assign a vector (or factor):\n\n# adding a column\ndat$new_column <- c('a', 'e', 'i')\ndat\n\n  name gender height  jedi new_column\n1 Leia female   1.50 FALSE          a\n2 Luke   male   1.72  TRUE          e\n3  Han   male   1.80 FALSE          i\n\n\nAnother way to add a column is with the column binding function cbind():\n\n# vector of weights\nweight <- c(49, 77, 85)\n\n# adding weights to dat\ndat <- cbind(dat, weight)\ndat\n\n  name gender height  jedi new_column weight\n1 Leia female   1.50 FALSE          a     49\n2 Luke   male   1.72  TRUE          e     77\n3  Han   male   1.80 FALSE          i     85\n\n\n\n\n9.4.3 Deleting a column\nThe inverse operation of adding a column consists of deleting a column. This is possible with the $ dollar operator. For instance, say you want to remove the column new_column. Use the $ operator to select this column, and assign it the value NULL (think of this as NULLifying a column):\n\n# deleting a column\ndat$new_column <- NULL\ndat\n\n  name gender height  jedi weight\n1 Leia female   1.50 FALSE     49\n2 Luke   male   1.72  TRUE     77\n3  Han   male   1.80 FALSE     85\n\n\n\n\n9.4.4 Renaming a column\nWhat if you want to rename a column? There are various options to do this. One way is by changing the column names attribute:\n\n# attributes\nattributes(dat)\n\n$names\n[1] \"name\"   \"gender\" \"height\" \"jedi\"   \"weight\"\n\n$row.names\n[1] 1 2 3\n\n$class\n[1] \"data.frame\"\n\n\nwhich is more commonly accessed with the names() function:\n\n# column names\nnames(dat)\n\n[1] \"name\"   \"gender\" \"height\" \"jedi\"   \"weight\"\n\n\nNotice that dat has a list of attributes. The element names is the vector of column names.\nYou can directly modify the vector of names; for example let’s change gender to sex:\n\n# changing rookie to rooky\nattributes(dat)$names[2] <- \"sex\"\n\n# display column names\nnames(dat)\n\n[1] \"name\"   \"sex\"    \"height\" \"jedi\"   \"weight\"\n\n\nBy the way: this approach of changing the name of a variable is very low level, and probably unfamiliar to most useRs.\n\n\n9.4.5 Moving a column\nA more challenging operation is when you want to move a column to a different position. What if you want to move salary to the last position (last column)? One option is to create a vector of column names in the desired order, and then use this vector (for the index of columns) to reassign the data frame like this:\n\nreordered_names <- c(\"name\", \"jedi\", \"height\", \"weight\", \"sex\")\ndat <- dat[ ,reordered_names]\ndat\n\n  name  jedi height weight    sex\n1 Leia FALSE   1.50     49 female\n2 Luke  TRUE   1.72     77   male\n3  Han FALSE   1.80     85   male\n\n\n\n\n9.4.6 Transforming a column\nA more common operation than deleting or moving a column, is to transform the values in a column. This can be easily accomplished with the $ operator. For instance, let’s say that we want to transform height from meters to centimeters:\n\n# converting height to centimeters\ndat$height <- dat$height * 100\ndat\n\n  name  jedi height weight    sex\n1 Leia FALSE    150     49 female\n2 Luke  TRUE    172     77   male\n3  Han FALSE    180     85   male\n\n\nLikewise, instead of using the $ operator, you can refer to the column using bracket notation. Here’s how to transform weight from kilograms to pounds (1 kg = 2.20462 pounds):\n\n# weight into pounds\ndat[ ,\"weight\"] <- dat[ ,\"weight\"] * 2.20462\ndat\n\n  name  jedi height   weight    sex\n1 Leia FALSE    150 108.0264 female\n2 Luke  TRUE    172 169.7557   male\n3  Han FALSE    180 187.3927   male\n\n\nThere is also the transform() function which transform values interactively, that is, temporarily:\n\n# transform weight to kgs\ntransform(dat, weight = weight / 0.453592)\n\n  name  jedi height   weight    sex\n1 Leia FALSE    150 238.1576 female\n2 Luke  TRUE    172 374.2476   male\n3  Han FALSE    180 413.1305   male\n\n\ntransform() does its job of modifying the values of weight but only temporarily; if you inspect dat you’ll see what this means:\n\n# did weight really change?\ndat\n\n  name  jedi height   weight    sex\n1 Leia FALSE    150 108.0264 female\n2 Luke  TRUE    172 169.7557   male\n3  Han FALSE    180 187.3927   male\n\n\nTo make the changes permanent with transform(), you need to reassign them to the data frame:\n\n# transform weight to inches (permanently)\ndat <- transform(dat, weight = weight / 0.453592)\ndat\n\n  name  jedi height   weight    sex\n1 Leia FALSE    150 238.1576 female\n2 Luke  TRUE    172 374.2476   male\n3  Han FALSE    180 413.1305   male"
  },
  {
    "objectID": "4-02-data-frames.html#exercises",
    "href": "4-02-data-frames.html#exercises",
    "title": "9  Data Frames",
    "section": "9.5 Exercises",
    "text": "9.5 Exercises\n1) Consider the following data frame df:\n\n\n      first      last  gender  born         spell\n1     Harry    Potter    male  1980  sectumsempra\n2  Hermione   Granger  female  1979     alohomora\n3       Ron   Weasley    male  1980    riddikulus\n4      Luna  Lovegood  female  1981       episkey\n\n\n\nWhat commands will fail to return the data of individuals born in 1980?\n\ndf[c(TRUE, FALSE, TRUE, FALSE), ]\ndf[df[,4] == 1980, ]\ndf[df$born == 1980]\ndf[df$born == 1980, ]\ndf[ ,df$born == 1980]\n\n\n\n\nShow answer\n# a) these options:\n# (i) df[df$born == 1980]\n# (v) df[ ,df$born == 1980]\n\n\n\nSelect the command that does not provide information about the data frame df:\n\nhead(df)\nstr(df)\ntail(df)\nrm(df)\nsummary(df)\n\n\n\n\nShow answer\n# b) this option:\n# (iv) rm(df)\n\n\n\nYour friend is trying to display the first three rows on columns 1 (first) and 2 (last), by unsuccessfully using the following command. Why does the command print all columns?\n\n\ndf[1:3, 1 & 2]\n\n     first    last gender born        spell\n1    Harry  Potter   male 1980 sectumsempra\n2 Hermione Granger female 1979    alohomora\n3      Ron Weasley   male 1980   riddikulus\n\n\n\n\nShow answer\n# c) The command \"df[1:3, 1 & 2]\" displays all columns \n# because \"1 & 2\" is a logical comparison that returns \n# \"TRUE\", and therefore all columns are selected.\n\n\n\nWrite a command that would correctly display the first two columns.\n\n\n\nShow answer\n# c) any of these:\n# df[1:3, 1:2]\n# df[1:3, c(1, 2)]\n# df[1:3, c('first', 'last')]\n\n\n\nWrite a command that would give you the following data from df.\n\n\n\n         spell    first\n1 sectumsempra    Harry\n2    alohomora Hermione\n3   riddikulus      Ron\n4      episkey     Luna\n\n\n\n\nShow answer\n# d) any of these\n# df[ ,c('spell', 'first')]\n# df[ ,c(5,1)]\n\n\n\n2) Consider the following data frame dat\n\n\n       first        last   gender      title   gpa\n1        Jon        Snow     male       lord   2.8\n2       Arya       Stark   female   princess   3.5\n3     Tyrion   Lannister     male     master   2.9\n4   Daenerys   Targaryen   female   khaleesi   3.7\n5       Yara     Greyjoy   female   princess    NA\n\n\nOne of your friends wrote the following R code. Help your friend find all the errors and explain what’s wrong.\n# value of 'first' associated to maximum 'gpa'\nmax_gpa <- max(dat$gpa, na.rm = TRUE)\nwhich_max_gpa <- dat$gpa = max_gpa\ndat$first(which_max_gpa)\n\n# gpa of title lord\ndat$gpa[dat[ ,title] = \"lord\"]\n\n# median gpa (of each gender)\nwhich_males <- dat$gender == 'male'\nwhich_females <- dat$gender == 'female'\nmedian_females <- median(dat$gpa[which_males])\nmedian_males <- median(dat$gpa[which_males])\n\n\nShow answer\n# There are five errors:\n# \n# dat$gpa = max_gpa should be dat$gpa == max_gpa\n#\n# dat$first(which_max_gpa) should be dat$first[which_max_gpa]\n#\n# dat$gpa[dat[ ,title] = \"lord\"], should use quotations \n# for \"title\" and also use double equals in: \n# dat$gpa[dat[ ,\"title\"] == \"lord\"]\n#\n# median_females <- median(dat$gpa[which_males]) should \n# be: median_females <- median(dat$gpa[which_females])"
  },
  {
    "objectID": "5-01-functions-intro.html",
    "href": "5-01-functions-intro.html",
    "title": "10  Intro to Functions",
    "section": "",
    "text": "R comes with many functions and packages that let us perform a wide variety of tasks, and so far we’ve been using a number of them. In fact, most of the things we do in R is by calling some function. Sometimes, however, there is no function to do what we want to achieve. When this is the case, we may very well want to write our own functions.\nIn this chapter we’ll describe how to start writing small and simple functions. We are going to start covering the “tip of the iceberg”, and in the following chapters we will continue discussing more aspects about writing functions, and describing how R works when you invoke (call) a function."
  },
  {
    "objectID": "5-01-functions-intro.html#motivation",
    "href": "5-01-functions-intro.html#motivation",
    "title": "10  Intro to Functions",
    "section": "10.1 Motivation",
    "text": "10.1 Motivation\nWe’ve used the formula of future value, given below, which is useful to answer questions like: If you deposit $1000 into a savings account that pays an annual interest of 2%, how much will you have at the end of year 10?\n\\[\n\\text{FV} = \\text{PV} \\times (1 + r)^n\n\\]\n\n\\(\\text{FV}\\) = future value (how much you’ll have)\n\\(\\text{PV}\\) = present value (the initial deposit)\n\\(r\\) = rate of return (e.g. annual rate of return)\n\\(n\\) = number of periods (e.g. number of years)\n\nR has a large number of functions—e.g. sqrt(), log(), mean(), sd(), exp(), etc—but it does not have a built-in function to compute future value.\nWouldn’t it be nice to have a future_value() function—or an fv() function—that you could call in R? Perhaps something like:\n\nfuture_value(present = 1000, rate = 0.02, year = 10)\n\nLet’s create such a function!"
  },
  {
    "objectID": "5-01-functions-intro.html#writing-a-simple-function",
    "href": "5-01-functions-intro.html#writing-a-simple-function",
    "title": "10  Intro to Functions",
    "section": "10.2 Writing a Simple Function",
    "text": "10.2 Writing a Simple Function\nThis won’t always be the case, but in our current example we have a specific mathematical formula to work with (which makes things a lot easier):\n\\[\n\\text{FV} = \\text{PV} \\times (1 + r)^n\n\\]\nLike other programming languages that can be used for scientific computations, we can take advantage of the syntax in R to write an expression that is almost identical to the algebraic formulation:\n\nfv = pv * (1 + r)^n\n\nWe will use this simple line of code as our starting point for creating a future value function. Here is how to do it “logically” step by step.\n\nStep 1: Start with a concrete example\nYou should always start with a small and concrete example, focusing on writing code that does the job. For example, we could write the following lines:\n\n# inputs\npv = 1000\nr = 0.02\nn = 10\n\n# process\nfv = pv * (1 + r)^n\n\n# output\nfv\n\n[1] 1218.994\n\n\nWhen I say “small example” I mean working with objects containing just a few values. Here, the objects pv, r, and n are super simple vectors of size 1. Sometimes, though, you may want to start with less simple—yet small—objects containing just a couple of values. That’s fine too.\nSometimes you may even need to start not just with one, but with a couple of concrete examples that will help you get a better feeling of what kind of objects, and operations you need to use.\nAs you get more experience creating and writing functions, you may want to start with a “medium-size” concrete example. Personally, I don’t tend to start like this. Instead, I like to take baby-steps, and I also like to take my time, without rushing the coding. You know the old-saying: “measure twice, cut once.”\nAn important part of starting with a concrete example is so that you can identify what the inputs are, what computations or process the inputs will go through, and what the output should be.\nInputs:\n\npv\nr\nn\n\nProcess:\n\nfv = pv * (1 + r)^n\n\nOutput:\n\nfv\n\n\n\nStep 2: Make your code more generalizable\nAfter having one (or a few) concrete example(s), the next step is to make your code more generalizable, or if you prefer, to make it more abstract (or at least less concrete).\nInstead of working with specific values pv, r, and n, you can give them a more algebraic spirit. For instance, the code below considers “open-ended” inputs without assigning them any values\n\n# general inputs (could take \"any\" values)\npv\nr\nn\n\n# process\nfv = pv * (1 + r)^n\n\n# output\nfv\n\nObviously this piece of code is very abstract and not intended to be executed in R; this is just for the sake of conceptual illustration.\n\n\nStep 3: Encapsulate the code into a function\nThe next step is to encapsulate your code as a formal function in R. I will show you how to do this in two logical substeps, although keep in mind that in practice you will merge these two substeps into a single one.\nThe encapsulation process involves placing the “inputs” inside the function function(), separating each input with a comma. Formally speaking, the inputs of your functions are known as the arguments of the function.\nLikewise, the lines of code that correspond to the “process” and “output” are what will become the body of the function. Typically, you encapsulate the code of the body by surrounding it with curly braces { }\n\n# encapsulating code into a function\nfunction(pv, r, n) {\n  fv = pv * (1 + r)^n\n  fv\n}\n\nThe other substep typically consists of assigning a name to the code of your function. For example, you can give it the name FV:\n\n# future value function\nFV = function(pv, r, n) {\n  fv = pv * (1 + r)^n\n  fv\n}\n\nIn summary:\n\nthe inputs go inside function(), separating each input with a comma\nthe processing step and the output are surrounded within curly braces { }\nyou typically assign a name to the code of your function\n\n\n\nStep 4: Test that the function works\nOnce the function is created, you test it to make sure that everything works. Very likely you will test your function with the small and concrete example:\n\n# test it\nFV(1000, 0.02, 10)\n\n[1] 1218.994\n\n\nAnd then you’ll keep testing your function with other less simple examples. In this case, because the code we are working with is based on vectors, and uses common functions for vectors, we can further inspect the behavior of the function by providing vectors of various sizes for all the arguments:\n\n# vectorized years\nFV(1000, 0.02, 1:5)\n\n[1] 1020.000 1040.400 1061.208 1082.432 1104.081\n\n\n\n# vectorized rates\nFV(1000, seq(0.01, 0.02, by = 0.005), 1)\n\n[1] 1010 1015 1020\n\n\n\n# vectorized present values\nFV(c(1000, 2000, 3000), 0.02, 1)\n\n[1] 1020 2040 3060\n\n\nNotice that the function is vectorized, this is because we are using arithmetic operators (e.g. multiplication, subtraction, division) which are in turn vectorized.\n\n\nIn Summary\n\nTo define a new function in R you use the function function().\nUsually, you specify a name for the function, and then assign function() to the chosen name.\nYou also need to define optional arguments (i.e. inputs of the function).\nAnd of course, you must write the code (i.e. the body) so the function does something when you use it.\n\n\n\n10.2.1 Arguments with default values\nSometimes it’s a good idea to add a default value to one (or more) of the arguments. For example, we could give default values to the arguments in such a way that when the user executes the function without any input, FV() returns the value of 100 monetary units invested at a rate of return of 1% for 1 year:\n\n# future value function with default arguments\nFV = function(pv = 100, r = 0.01, n = 1) {\n  fv = pv * (1 + r)^n\n  fv\n}\n\n# default execution\nFV()\n\n[1] 101\n\n\nAn interesting side effect of giving default values to the arguments of a function is that you can also call it by specifying arguments in an order different from the order in which the function was created:\n\nFV(r = 0.02, n = 3, pv = 1000)\n\n[1] 1061.208"
  },
  {
    "objectID": "5-01-functions-intro.html#writing-functions-for-humans",
    "href": "5-01-functions-intro.html#writing-functions-for-humans",
    "title": "10  Intro to Functions",
    "section": "10.3 Writing Functions for Humans",
    "text": "10.3 Writing Functions for Humans\nWhen writing functions (or coding in general), you should write code not just for the computer, but also for humans. While it is true that R doesn’t care too much about what names and symbols you use, your code will be used by a human being: either you or someone else. Which means that a human will have to take a look at the code.\nHere are some options to make our code more human friendly. We can give the function a more descriptive name such as future_value(). Likewise, we can use more descriptive names for the arguments: e.g. present, rate, and years.\n\n# future value function\nfuture_value = function(present, rate, years) {\n  future = present * (1 + rate)^years\n  future\n}\n\n# test it\nfuture_value(present = 1000, rate = 0.02, years = 10)\n\n[1] 1218.994\n\n\nEven better: whenever possible, as we just said, it’s a good idea to give default values to the arguments (i.e. inputs) of the function:\n\n# future value function\nfuture_value = function(present = 100, rate = 0.01, years = 1) {\n  future = present * (1 + rate)^years\n  future\n}\n\nfuture_value()\n\n[1] 101\n\n\n\n10.3.1 Naming Functions\nSince we just change the name of the function from fv() to future_value(), you should also learn about the rules for naming R functions. A function cannot have any name. For a name to be valid, two things must happen:\n\nthe first character must be a letter (either upper or lower case) or the dot .\nbesides the dot, the only other symbol allowed in a name is the underscore _ (as long as it’s not used as the first character)\n\nFollowing the above two principles, below are some valid names that could be used for the future value function:\n\nfv()\nfv1()\nfuture_value()\nfuture.value()\nfutureValue()\n.fv(): a function that starts with a dot is a valid name, but the function will be a hidden function.\n\nIn contrast, here are examples of invalid names:\n\n1fv(): cannot begin with a number\n_fv(): cannot begin with an underscore\nfuture-value(): cannot use hyphenated names\nfv!(): cannot contain symbols other than the dot and the underscore (not in the 1st character)\n\n\n\n10.3.2 Function’s Documentation\nPart of writing a human-friendly function involves writing its documentation, usually providing the following information:\n\ntitle: short title\ndescription: one or two sentences of what the function does\narguments: short description for each of the arguments\noutput: description of what the function returns\n\nOnce you are happy with the status of your function, include comments for its documentation, for example:\n\n# title: future value function\n# description: computes future value using compounding interest\n# inputs:\n# - present: amount for present value\n# - rate: annual rate of return (in decimal)\n# - years: number of years\n# output:\n# - computed future value\nfuture_value = function(present = 100, rate = 0.01, years = 1) {\n  future = present * (1 + rate)^years\n  future\n}\n\nWriting documentation for a function seems like a waste of time and energy. Shouldn’t a function (with its arguments, body, and output) be self-descriptive? In an ideal world that would be the case, but this rarely happens in practice.\nYes, it does take time to write these comments. And yes, you will be constantly asking yourself the same question: “Do I really need to document this function that I’m just planning to use today, and no one else will ever use?”\nYes!\nI’ll be the first one to admit that I’ve created so many functions without writing their documentation. And almost always—sooner or later—I’ve ended up regretting my laziness for not including the documentation. So do yourself and others (especially your future self) a big favor by including some comments to document your functions.\nEnough about this chapter. Although, obviously, we are not done yet with functions. After all, this is a book about programming in R, and there is still a long way to cover about the basics and not so basics of functions."
  },
  {
    "objectID": "5-01-functions-intro.html#exercises",
    "href": "5-01-functions-intro.html#exercises",
    "title": "10  Intro to Functions",
    "section": "10.4 Exercises",
    "text": "10.4 Exercises\n1) In the second part of the book we have talked about the Future Value (FV), and we have extensively used its simplest version of the FV formula. Let’s now consider the “opposite” value: the Present Value which is the current value of a future sum of money or stream of cash flows given a specified rate of return.\nConsider the simplest version of the formula to calculate the Present Value given by:\n\\[\n\\text{PV} = \\frac{\\text{FV}}{(1 + r)^n}\n\\]\n\n\\(\\text{PV}\\) = present value (the initial deposit)\n\\(\\text{FV}\\) = future value (how much you’ll have)\n\\(r\\) = rate of return (e.g. annual rate of return)\n\\(n\\) = number of periods (e.g. number of years)\n\nWrite a function present_value() to compute the Present Value based on the above formula.\n\n\nShow answer\npresent_value = function(future, rate, year) {\n  present = future / (1 + rate)^year\n  return(present)\n}\n\n\n\n2) Write another function to compute the Future Value, but this time the output should be a list with two elements:\n\nvector year from 0 to provided year\nvector amount from amount at year 0, till amount at the provided year\n\nFor example, something like this:\n\n\n\n\nfv_list(present = 1000, rate = 0.02, year = 3)\n\n$year\n[1] 0 1 2 3\n\n$amount\n[1] 1000.000 1020.000 1040.400 1061.208\n\n\n\n\nShow answer\nfv_list <- function(present, rate, year) {\n  future = present * (1 + rate)^(0:year)\n  list(year = 0:year, amount = future)\n}\n\n\n\n3) Write another function to compute the Future Value, but this time the output should be a “table” with two columns: year and amount. For example, something like this:\n\n\n\n\nfv_table(present = 1000, rate = 0.02, year = 3)\n\n  year   amount\n1    0 1000.000\n2    1 1020.000\n3    2 1040.400\n4    3 1061.208\n\n\nNote: by “table” you can use either a matrix or a data.frame. Even better, try to create two separate functions: 1) fv_matrix() that returns a matrix, and 2) fv_df() that returns a data frame.\n\n\nShow answer\nfv_table <- function(present, rate, year) {\n  future = present * (1 + rate)^(0:year)\n  data.frame(year = 0:year, amount = future)\n}"
  },
  {
    "objectID": "5-02-expressions.html",
    "href": "5-02-expressions.html",
    "title": "11  Expressions",
    "section": "",
    "text": "In this chapter you will learn about R expressions which is a technical concept that appears everywhere in all R programming structures (e.g. functions, conditionals, loops). This chapter, by the way, is the shortest of the book. But its implications are fundamental to get a solid understanding of programming structures in R."
  },
  {
    "objectID": "5-02-expressions.html#r-expressions",
    "href": "5-02-expressions.html#r-expressions",
    "title": "11  Expressions",
    "section": "11.1 R Expressions",
    "text": "11.1 R Expressions\nBefore moving on with more programming structures we must first talk about R expressions.\n\n11.1.1 Simple Expressions\nSo far you’ve been writing several lines of code in R, most of which have been simple expressions such as:\n\ndeposit = 1000\nrate = 0.02\nyear = 3\n\nThe expression deposit = 1000 is an assignment statement because we assign the number 1000 to the name deposit. It is also a simple expression. The same can be said about the expressions for rate and year.\nSimple expressions are fairly common but they are not the only ones. It turns out that there is another class of expressions known as compound expressions.\n\n\n11.1.2 Compound Expressions\nR programs are made up of expressions which can be either simple expressions or compound expressions. Compound expressions consist of simple expressions separated by semicolons or newlines, and grouped within braces.\n# structure of a compound expression\n# with simple expressions separated by semicolons\n{expression_1; expression_2; ...; expression_n}\n\n# structure of a compound expression\n# with simple expressions separated by newlines\n{\n  expression_1\n  expression_2\n  expression_n\n}\nHere’s a less abstract example:\n\n# simple expressions separated by semicolons\n{\"first\"; 1; 2; 3; \"last\"}\n\n[1] \"last\"\n\n# simple expressions separated by newlines\n{\n  \"first\"\n  1\n  2\n  3\n  \"last\"\n}\n\n[1] \"last\"\n\n\nWriting compound expressions like those in the previous example is not something common among R users. Although the expressions are perfectly valid, these examples are very dummy (just for illustration purposes). By the way, I strongly discourage you from grouping multiple expressions with semicolons because it makes it difficult to inspect things.\nWhat does R do with a compound expression? When R encounters a compound expression, it handles everything inside of it as a single unit or a single block of code.\nWhat is the purpose of a compound expression? This kind of expression plays an important role but it is typically used together with other programming structures (e.g. functions, conditionals, loops).\n\n\n11.1.3 Every expression has a value\nA fundamental notion about expressions is that every expression in R has a value.\nConsider this simple expression:\n\na <- 5\n\nIf I ask you: What is the value of a?, you should have no trouble answering this question. You know that a has the value 5.\nWhat about this other simple expression:\n\nb <- 1:5\n\nWhat is the value of b? You know as well that the value of b is the numeric sequence given by 1 2 3 4 5.\nNow, let’s consider the following compound expression:\n\nx <- {5; 10}\n\nNote that the entire expression is assigned to x. Let me ask you the same question. What is the value of x? Is it:\n\n5?\n10?\n5, 10?\n\nLet’s find out the answer by taking a look at x:\n\nx\n\n[1] 10\n\n\nMmmm, this is interesting. As you can tell, x has a single value, and it’s not 5 but 10. Out of curiosity, let’s also consider this other compound expression for y and examine its value:\n\ny <- {\n  15\n  10\n  5\n}\n\ny\n\n[1] 5\n\n\nSame thing, y has a single value, the number 5, which happens to be the last statement inside the expression that was evaluated. This is precisely the essence of an R expression. Every R expression has a value, the value of the last statement that gets evaluated.\nTo make sure you don’t forget it, repeat this mantra:\n\n\nEvery expression in R has a value: the value of the last evaluated statement.\nEvery expression in R has a value: the value of the last evaluated statement.\nEvery expression in R has a value: the value of the last evaluated statement.\n\n\n\n\n11.1.4 Assignments within Compound Expressions\nIt is possible to have assignments within compound expressions. For instance:\n\n# simple expressions (made up of assignments) separated by newlines\n{\n  one <- 1\n  pie <- pi\n  zee <- \"z\"\n}\n\nThis compound expression contains three simple expressions, all of which are assignments. Interestingly, when an R expression contains such assignments, the values of the variables can be used in later expressions. In other words, you can refer later to one or pie or zee:\n\n# simple expressions (made up of assignments) separated by newlines\n{\n  one <- 1\n  pie <- pi\n  zee <- \"z\"\n}\n\none\n\n[1] 1\n\npie\n\n[1] 3.141593\n\nzee\n\n[1] \"z\"\n\n\nHere’s another example:\n\nz <- { x = 10 ; y = x^2; x + y }\n\nx\n\n[1] 10\n\ny\n\n[1] 100\n\nz\n\n[1] 110\n\n\nNow that we’ve introduced the concept of compound expressions, we can move on to next chapter where we introduce conditional structures."
  },
  {
    "objectID": "5-03-conditionals.html",
    "href": "5-03-conditionals.html",
    "title": "12  Conditionals: If-Else",
    "section": "",
    "text": "In the last two chapters you got your feet wet around programming structures. Specifically, you got your first contact with functions, and you also got introduced to the notion of R compound expressions. In this chapter you will learn about another common programming structure known as conditionals.\nEvery programming language comes with a set of structures that allows us to have control over how commands are executed. One of these structures is called conditionals, and as its name indicates, they are used to evaluate conditions. Simply put, conditional statements, commonly referred to as if-else statements, allow you to decide what to do based on a logical condition."
  },
  {
    "objectID": "5-03-conditionals.html#motivation",
    "href": "5-03-conditionals.html#motivation",
    "title": "12  Conditionals: If-Else",
    "section": "12.1 Motivation",
    "text": "12.1 Motivation\nSo far we have extensively used a simple savings-investing scenario in which $1000 are deposited in a savings account that pays an annual interest rate of 2%, and the future value formula is used to calculate the amount of money at the end of a certain number of years.\nLet’s now consider a less simplistic savings scenario.\nSay you deposit $1000 into a savings account that gives you 2% annual return. The difference this time is that you will also make contributions of $1000 to this savings account every year. The question is still the same, for example:\n\nHow much money will you have in 3 years?\n\n\n12.1.1 Future Value of Ordinary Annuity\nTo make things more specific, consider the following scenario. Imagine you recently applied for a job, they hired you, and today is your first day of work. So let’s take this point in time as time 0, or equivalently the beginning of year 1 in your new job.\nDuring this first year you manage to save $1000, and at the end of year 1 you deposit this sum of money into a savings account that pays 2% interest annually. During your second year of work, you manage again to save $1000, which you add to your savings account at the very end of year 2. The same thing happens during your third year of work: you save $1000 and contribute this amount to your savings account at the end of year 3. This is illustrated in the diagram below, with a generic rate of return:\n\n\n\n\n\nTimeline of an ordinary annuity: contributions made at the end of each year.\n\n\n\n\nThe balance in your savings account at the end of year 3 is given by:\n\\[\n\\underbrace{1000 (1 + 0.02)^2}_{\\text{1st contribution}} + \\underbrace{1000 (1 + 0.02)}_{\\text{2nd contrib.}} + \\underbrace{1000}_{\\text{3rd contrib.}} = 3060.4\n\\]\nwhich in R we can quickly calculate as:\n\n1000 * (1.02)^2 + 1000 * (1.02) + 1000\n\n[1] 3060.4\n\n\nThis example corresponds to what is formally called an ordinary annuity. It is an annuity because the same amount of money is contributed every year. It is ordinary because the contributions are made at the end of each period (e.g. end of each year).\nThe formula to calculate the future value of an ordinary annuity is given by:\n\\[\n\\text{FV} = \\text{C} \\times \\left [ \\frac{(1 + r)^t - 1}{r} \\right]\n\\]\n\n\\(\\text{FV}\\) = future value (how much you’ll have)\n\\(\\text{C}\\) = constant periodic contribution\n\\(r\\) = rate of return (e.g. annual rate of return)\n\\(t\\) = number of periods (e.g. number of years)\n\nWriting code in a less quick and dirty way, we may type the following commands:\n\n# at the end of year 3\ncontrib = 1000\nyear = 3\nrate = 0.02\n\n# FV of ordinary annuity\ncontrib * ((1 + rate)^year - 1) / rate\n\n[1] 3060.4\n\n\n\n\n12.1.2 Future Value of Annuity Due\nIt turns out that there is another type of annuity known as annuity due. The difference between the ordinary annuity and the annuity due is that in the latter the contributions are made at the beginning of every year. Here’s an example.\nPicture the same hypothetical situation. Today is your first day of work which corresponds to time 0, that is, the beginning of year 1 in your new job. In this scenario let’s assume you already have $1000 at your disposal at this point in time. You go to the bank and deposit this sum of money into a savings account that pays an annual interest rate of 2%.\nDuring this first year you manage to save $1000, and at the beginning of year 2 you make this contribution to your savings account. During your second year of work, you manage again to save $1000, which you add to your savings account at the beginning of year 3. This is illustrated in the diagram below, with a generic rate of return:\n\n\n\n\n\nTimeline of an annuity due: contributions made at the beginning of each year.\n\n\n\n\nThe balance in your savings account at the end of year 3 is given by:\n\\[\n\\underbrace{1000 (1 + 0.02)^3}_{\\text{1st contribution}} + \\underbrace{1000 (1 + 0.02)^2}_{\\text{2nd contrib.}} + \\underbrace{1000 (1 + 0.02)}_{\\text{3rd contrib.}} = 3121.608\n\\]\nwhich in R we can quickly calculate as:\n\n1000 * (1.02)^3 + 1000 * (1 + 0.02)^2 + 1000 * (1 + 0.02)\n\n[1] 3121.608\n\n\nThe formula to calculate the future value of an annuity due is given by:\n\\[\n\\text{FV} = \\text{C} \\times \\left [ \\frac{(1 + r)^t - 1}{r} \\right] \\times (1 + r)\n\\]\n\n\\(\\text{FV}\\) = future value (how much you’ll have)\n\\(\\text{C}\\) = constant periodic contribution\n\\(r\\) = rate of return (e.g. annual rate of return)\n\\(t\\) = number of periods (e.g. number of years)\n\nIn a less informal way, we can write the following lines of code:\n\n# at the end of year 3\ncontrib = 1000\nyear = 3\nrate = 0.02\n\n# FV of annuity due\ncontrib * (1 + rate) * ((1 + rate)^year - 1) / rate\n\n[1] 3121.608\n\n\nAs you know, we can also consider a vectorized option to obtain the amounts at the end of every year:\n\n# over a 3 year period\ncontrib = 1000\nyears = 1:3\nrate = 0.02\n\n# FV of annuity due\ncontrib * (1 + rate) * ((1 + rate)^years - 1) / rate\n\n[1] 1020.000 2060.400 3121.608"
  },
  {
    "objectID": "5-03-conditionals.html#conditionals",
    "href": "5-03-conditionals.html#conditionals",
    "title": "12  Conditionals: If-Else",
    "section": "12.2 Conditionals",
    "text": "12.2 Conditionals\nLet’s do a quick recap. We know there are two types of annuity:\n\nordinary (contributions at the end of each period)\ndue (contributions at the beginning of each period)\n\nAnd we also have their corresponding future value formulas:\n\nfuture value of an ordinary annuity:\n\n\\[\n\\text{FV} = \\text{C} \\times \\left [ \\frac{(1 + r)^t - 1}{r} \\right]\n\\]\n\nfuture value of an annuity due:\n\n\\[\n\\text{FV} = \\text{C} \\times \\left [ \\frac{(1 + r)^t - 1}{r} \\right] \\times (1 + r)\n\\]\nLet us now consider the possibility of having an input object (or variable) called type that can take two values: type = \"ordinary\" or type = \"due\". Depending on the value of type, we could write code to compute the appropriate kind of annuity, something more or less like the code below:\n\n# in 3 years\ncontrib = 1000\nyears = 1:3\nrate = 0.02\n\nOrdinary annuity:\n\n# if type == \"ordinary\"\ncontrib * ((1 + rate)^years - 1) / rate\n\n[1] 1000.0 2020.0 3060.4\n\n\nAnnuity due:\n\n# if type == \"due\"\ncontrib * (1 + rate) * ((1 + rate)^years - 1) / rate\n\n[1] 1020.000 2060.400 3121.608\n\n\n\n12.2.1 If-else conditions\nPerhaps the best way for you to get introduced to if-else statements is to see one for yourself, so here it is:\n\n# ordinary annuity\ncontrib = 1000\nyears = 1:3\nrate = 0.02\ntype = \"ordinary\"\n\n# if-else statement\nif (type == \"ordinary\") {\n  fv = contrib * ((1 + rate)^years - 1) / rate\n} else {\n  fv = contrib * (1 + rate) * ((1 + rate)^years - 1) / rate\n}\n\nfv\n\n[1] 1000.0 2020.0 3060.4\n\n\nI hope that just by looking at the precending conditional statement you get the gist of what is going on. If the type of annuity is the ordinary one (type == \"ordinary\") then we apply the formula of the FV of ordinary annuity. Otherwise (else) we apply the formula of the FV of annuity due.\nThe same piece of code can be implemented with the other type of annuity\n\n# annuity due\ncontrib = 1000\nyears = 1:3\nrate = 0.02\ntype = \"due\"\n  \nif (type == \"ordinary\") {\n  fv = contrib * ((1 + rate)^years - 1) / rate\n} else {\n  fv = contrib * (1 + rate) * ((1 + rate)^years - 1) / rate\n}\n\nfv\n\n[1] 1020.000 2060.400 3121.608\n\n\n\n\n12.2.2 Anatomy of if-else statements\nThe if-then-else statement makes it possible to choose between two (possibly compound) expressions depending on the value of a (logical) condition.\nIn R (as in many other languages) the if-then-else statement has the following structure:\nif (condition) {\n  # do something\n} else {\n  # do something else\n}\nIn our working example with the two types of annuities, the condition that we are evaluating depends on the value of type:\nif (type == \"ordinary\") {\n  # compute ordinary annuity\n} else {\n  # compute annuity due\n}\nIf type == \"ordinary\", then we should compute the future value of annuity using its ordinary version. Otherwise, we should compute the future value using the annuity due formula.\nLet’s dissect the conditional statement\n\n\n\n\n\n\n\n\n\nAn if-else statement always begins with the if clause. You basically refer to it as a function, that is, employing parenthesis if( ). The thing that goes inside parenthesis corresponds to the logical condition to be evaluated. Then we have the R expression, defined with the first pair of braces { } that contains the code to be executed when the logical condition is true. Next, right after the closing brace of the expression associated to the if-clause, we have the else clause. This second clause involves another R expression, the one defined with a second pair of braces. This expression contains the code to be executed when the logical condition is false.\nFor readability purposes, and to match the syntax used in many other programming languages, when declaring the if clause I prefer to leave a blank space before the opening parenthesis: if (condition).\nUsing the annuity example, let’s recap the main parts of a typical if-else statement. In general, this kind of statement consists of the if clause and the else clause. Only the if clause uses parenthesis.\n\n\n\n\n\n\n\n\n\nInside the if() function, you specify a condition to be evaluated. This condition can be almost any piece of code that R will evaluate into a logical value. The important thing about this condition is that it must correspond to a single logical value, either a single TRUE or a single FALSE.\nThe condition is an expression that when evaluated returns a logical value of length one. In other words, whatever you pass as the input of the if clause, it has to be something that becomes TRUE or FALSE\n\n\n\n\n\n\n\n\n\nIn general, an R expression—using braces { }—is used for each clause: the first one with the code that tells R what to do when the evaluated condition is true; the second one for what to do when the condition is false.\n\n\n\n\n\n\n\n\n\n\n\n12.2.3 Minimalist If-then-else\nif-else statements can be written in different forms, depending on the types of expressions that are evaluated. If the expressions of both the if clause and the else clause are simple expressions, the syntax of the if-else code can be simplified into one line of code:\nif (condition) expression_1 else expression_2\nConsider the following example that uses a conditional statement to decide between calculating the square root of the input if the input value is positive, or computing the negative square root of the negative input if the input value is negative:\n\nx <- 10\n\nif (x > 0) {\n  y <- sqrt(x) \n} else {\n  y <- -sqrt(-x)\n}\ny\n\n[1] 3.162278\n\n\nBecause the code in both clauses consists of simple expressions, the use of braces is not mandatory. In fact, you can write the conditional statement in a single line of code, as follows:\nx <- 10\n\n# with simple expressions, braces are optional\nif (x > 0) y <- sqrt(x) else y <- -sqrt(-x)\n\ny\nInterestingly, the previous statement can be written more succinctly in R as:\nx <- 10\n\n# you can assign the output of an if-else statement\n# to an object\ny <- if (x > 0) sqrt(x) else -sqrt(-x)\n\ny\nAgain, even though the previous commands are perfectly okay, I prefer to use braces when working with conditional structures. This is a good practice that improves readability:\n\n# embrace braces: use them as much as possible!\nx <- 10\n\nif (x > 0) {\n  y <- sqrt(x) \n} else {\n  y <- -sqrt(-x)\n}\n\n\n\n12.2.4 Simple If’s\nThere is a simplified form of if-else statement which is available when there is no expression in the else clause. In its simplest version this statement has the general form:\nif (condition) expression\nand it is equivalent to:\nif (condition) expression else NULL\nHere’s an example in which we have two numbers, x and y, and we are interested in knowing if x is greater than y. If yes, we print the message \"x is greater than y\". If not, then we don’t really care, and we do nothing.\n\nx <- 4\ny <- 2\n\nif (x > y) {\n  print(\"x is greater than y\")\n}\n\n[1] \"x is greater than y\""
  },
  {
    "objectID": "5-03-conditionals.html#multiple-ifs",
    "href": "5-03-conditionals.html#multiple-ifs",
    "title": "12  Conditionals: If-Else",
    "section": "12.3 Multiple If’s",
    "text": "12.3 Multiple If’s\nA common situation involves working with multiple conditions at the same time. You can chain multiple if-else statements like so:\n\ny <- 1 # Change this value!\n\nif (y > 0) {\n  print(\"positive\")\n} else if (y < 0) {\n  print(\"negative\")\n} else {\n  print(\"zero?\")\n}\n\n[1] \"positive\"\n\n\nWorking with multiple chained if’s becomes cumbersome. Consider the following example that uses several if’s to convert a day of the week into a number:\n\n# Convert the day of the week into a number.\nday <- \"Tuesday\" # Change this value!\n\nif (day == 'Sunday') {\n  num_day <- 1\n} else {\n  if (day == \"Monday\") {\n    num_day <- 2\n  } else {\n    if (day == \"Tuesday\") {\n      num_day <- 3\n    } else {\n      if (day == \"Wednesday\") {\n        num_day <- 4\n      } else {\n        if (day == \"Thursday\") {\n          num_day <- 5\n        } else {\n          if (day == \"Friday\") {\n            num_day <- 6\n          } else {\n            if (day == \"Saturday\") {\n              num_day <- 7\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nnum_day\n\n[1] 3\n\n\nWorking with several nested if’s like in the example above can be a nightmare.\nIn R, you can get rid of many of the braces like this:\n\n# Convert the day of the week into a number.\nday <- \"Tuesday\" # Change this value!\n\nif (day == 'Sunday') {\n  num_day <- 1\n} else if (day == \"Monday\") {\n  num_day <- 2\n} else if (day == \"Tuesday\") {\n  num_day <- 3\n} else if (day == \"Wednesday\") {\n  num_day <- 4\n} else if (day == \"Thursday\") {\n  num_day <- 5\n} else if (day == \"Friday\") {\n  num_day <- 6\n} else if (day == \"Saturday\") {\n  num_day <- 7\n}\n\nnum_day\n\n[1] 3\n\n\n\n12.3.1 Switch statements\nBut still we have too many if’s, and there’s a lot of repetition in the code. If you find yourself using many if-else statements with identical structure for slightly different cases, you may want to consider a switch statement instead:\n\n# Convert the day of the week into a number.\nday <- \"Tuesday\" # Change this value!\n\nswitch(day, # The expression to be evaluated.\n  Sunday = 1,\n  Monday = 2,\n  Tuesday = 3,\n  Wednesday = 4,\n  Thursday = 5,\n  Friday = 6,\n  Saturday = 7,\n  NA) # an (optional) default value if there are no matches\n\n[1] 3\n\n\nSwitch statements can also accept integer arguments, which will act as indices to choose a corresponding element:\n\n# Convert a number into a day of the week.\nday_num <- 3 # Change this value!\n\nswitch(day_num,\n  \"Sunday\",\n  \"Monday\",\n  \"Tuesday\",\n  \"Wednesday\",\n  \"Thursday\",\n  \"Friday\",\n  \"Saturday\")\n\n[1] \"Tuesday\""
  },
  {
    "objectID": "5-03-conditionals.html#derivation-of-fvoa",
    "href": "5-03-conditionals.html#derivation-of-fvoa",
    "title": "12  Conditionals: If-Else",
    "section": "12.4 Derivation of FVOA",
    "text": "12.4 Derivation of FVOA\nIn case you are curious, here’s the derivation of the formula for the Future Value of an Ordinary Annuity.\nFor the sake of illustration, we’ll consider a time period of three years, but the formula can be easily generalized to any number of years.\n\n\n\n\n\nTimeline of an ordinary annuity\n\n\n\n\nThe starting point is the following equation:\n\\[\n\\text{FV} = \\text{C} + \\text{C} (1 + r) + \\text{C} (1 + r)^2\n\\]\nMultiplying both sides by \\((1+r)\\) we get:\n\\[\\begin{align*}\n(1+r) \\text{FV} &= (1+r) \\left[ \\text{C} + \\text{C} (1 + r) + \\text{C} (1 + r)^2 \\right] \\\\\n(1+r) \\text{FV} &= (1+r) \\text{C} + \\text{C} (1 + r)^2 + \\text{C} (1 + r)^3\n\\end{align*}\\]\nNotice that:\n\\[\n(1+r) \\text{FV} = \\underbrace{\\text{C} (1 + r) + \\text{C} (1 + r)^2}_{\\text{FV} - \\text{C}}  + \\text{C} (1 + r)^3\n\\]\nDoing more algebra we get the following:\n\\[\\begin{align*}\n(1+r) \\text{FV} &= \\underbrace{\\text{C} (1 + r) + \\text{C} (1 + r)^2}_{\\text{FV} - \\text{C}}  + \\text{C} (1 + r)^3 \\\\\n(1+r) \\text{FV} &= \\text{FV} - \\text{C} + \\text{C} (1 + r)^3 \\\\\n\\text{FV} - (1+r) \\text{FV} &= \\text{C} - \\text{C}(1+r)^3 \\\\\n\\text{FV} \\left[ 1 - (1+r)  \\right] &= \\text{C} \\left[ 1 - (1+r)^3 \\right] \\\\\n\\text{FV} &= \\text{C} \\frac{ \\left[ 1 - (1+r)^3 \\right]}{ \\left[ 1 - (1+r) \\right]} \\\\\n\\text{FV} &= \\text{C} \\frac{ \\left[ (1+r)^3 -1 \\right]}{ \\left[ (1+r) -1 \\right]} \\\\\n\\text{FV} &= \\text{C} \\left[ \\frac{(1+r)^3 -1}{r} \\right]\n\\end{align*}\\]\nTherefore:\n\\[\n\\text{FV} = \\text{C} + \\text{C} (1 + r) + \\text{C} (1 + r)^2 = \\text{C} \\left[ \\frac{(1+r)^3 -1}{r} \\right]\n\\]"
  },
  {
    "objectID": "5-04-for-loop.html",
    "href": "5-04-for-loop.html",
    "title": "13  Iterations: For Loop",
    "section": "",
    "text": "In the previous chapter you got introduced to conditional statements, better known as if-else statements. In this chapter we introduce another common programming structure known as iterations. Simply put iterative procedures commonly referred to as loops, allow you to repeat a series of common steps."
  },
  {
    "objectID": "5-04-for-loop.html#motivation",
    "href": "5-04-for-loop.html#motivation",
    "title": "13  Iterations: For Loop",
    "section": "13.1 Motivation",
    "text": "13.1 Motivation\nSay you decide to invest $1000 in an investment fund that tracks the performance of the total US stock market. This type of financial asset, commonly referred to as a total stock fund is a mutual fund or an exchange traded fund (ETF) that holds every stock in a selected market. The purpose of a total stock fund is to replicate the broad market by holding the stock of every security that trades on a certain exchange. From the investing point of view, these funds are ideal for investors who want exposure to the overall equity market at a very low cost.\nExamples of such funds are:\n\nVTSAX: Vanguard Total Stock Market Index Fund\nFSKAX: Fidelity Total Stock Market Index Fund\nSWTSX: Schwab Total Stock Market Index Fund\n\nAs we were saying, you decide to invest $1000 in a total stock market index fund (today).\n\nHow much money would you expect to get in 10 years?\n\nIf we knew the annual rate of return, we could use the future value formula (of compound interest)\n\\[\n\\text{FV} = \\$1000 \\times (1 + r)^{10}\n\\]\nThe problem, or the “interesting part”—depending on how you want to see it—is that total stock funds don’t have a constant annual rate of return. Why not? Well, because the stock market is volatile, permanently moving up and down every day, with prices of stocks fluctuating every minute.\nDespite the variability in prices of stocks, it turns out that in most (calendar) years, the annual return is positive. But not always. There are some years in which the annual return can be negative.\n\n13.1.1 US Stock Market Historical Annual Returns\nWe can look at historical data to get an idea of the average annual return for investing in the total US stock market. One interesting resource that gives a nice perspective of the historical distribution of US stock market returns comes from amateur investor Joachim Klement\nhttps://klementoninvesting.substack.com/p/the-distribution-of-stock-market\n\n\n\n\n\nDistribution of Annual Returns (by Joachim Klement)\n\n\n\n\nAs you can tell, on an annual scale, market returns are basically random and follow the normal distribution fairly well.\nSo let us assume that annual rates of return for the total US Stock Market have a Normal distribution with mean \\(\\mu = 10\\%\\) and standard deviation \\(\\sigma = 18\\%\\).\nMathematically, we can write something like this:\n\\[\nr_t \\sim \\mathcal{N}(\\mu = 0.10, \\ \\sigma = 0.18)\n\\]\nwhere \\(r_t\\) represents the annual rate of return in any given year \\(t\\).\nThis means that, on average, we expect 10% return every year. But a return between 28% = 10% + 18%, and -2% = 10% - 18%, it’s also a perfectly reasonable return in every year.\nIn other words, there is nothing surprising if you see years where the return is any value between -2% and 28%.\nAdmittedly, we don’t know what’s going to happen with the US Stock Market in the next 10 years. But we can use our knowledge of the long-term regular behavior of the market to guesstimate an expected return in 10 years. If we assume that the (average) annual return for investing in a total market index fund is 10%, then we could estimate the expected future value as:\n\\[\n\\textsf{expected } \\text{FV} = \\$ 1000 \\times (1 + 0.10)^{10} = \\$ 2593.742\n\\]\nKeep in mind that one of the limitations behind this assumption is that we are not taking into account the volatility of the stock market. This is illustrated in the following figure that compares a theoretical scenario with constant 10% annual returns, versus a plausible scenario with variable returns in each year.\n\n\n\n\n\nRates of Return: Fixed -vs- Variable"
  },
  {
    "objectID": "5-04-for-loop.html#simulating-normal-random-numbers",
    "href": "5-04-for-loop.html#simulating-normal-random-numbers",
    "title": "13  Iterations: For Loop",
    "section": "13.2 Simulating Normal Random Numbers",
    "text": "13.2 Simulating Normal Random Numbers\nBecause the stock market is volatile, we need a way to simulate random rates of return. The good news is that we can use rnorm() to simulate generating numbers from a Normal distribution. By default, rnorm() generates a random number from a standard normal distribution (mean = 0, standard deviation = 1)\n\nset.seed(345)  # for replication purposes\nrnorm(n = 1, mean = 0, sd = 1)\n\n[1] -0.7849082\n\n\nHere’s how to simulate three rates from a Normal distribution with mean \\(\\mu = 0.10\\) and \\(\\sigma = 0.18\\)\n\nrates = rnorm(n = 3, mean = 0.10, sd = 0.18)\nrates\n\n[1] 0.04968742 0.07093758 0.04769262\n\n\n\n13.2.1 Investing in the US stock market during three years\nTo understand what could happen with your investment, let’s focus on a three year horizon. For each yar, we need a random rate of return \\(r_t\\) (\\(t\\) = 1, 2, 3)\n\n\n\n\n\nRandom rates of return following a normal distribution\n\n\n\n\nAs we mentioned, we can use rnorm() to generate three random rates of return from a normal distribution with \\(\\mu = 0.10\\) and \\(\\sigma = 0.18\\)\n\n# inputs, consider investing during three years\nset.seed(345)   # for replication purposes\namount0 = 1000\nrates = rnorm(n = 3, mean = 0.10, sd = 0.18)\nrates\n\n[1] -0.04128347  0.04968742  0.07093758\n\n\nWith these rates, we can then calculate the amounts in the investment fund that we could expect to have at the end of each year:\n\n# output: balance amount at the end of each year\namount1 = amount0 * (1 + rates[1])\namount2 = amount1 * (1 + rates[2])\namount3 = amount2 * (1 + rates[3])\n\nc(amount1, amount2, amount3)\n\n[1]  958.7165 1006.3527 1077.7409\n\n\nNotice the common structure in the commands used to obtain an amount value. Moreover, notice that we are repeating the same operation three times. At this point you may ask yourself whether we could vectorize this code. Let’s see if we can:\n\n# vectorized attempt 1\namounts = amount0 * (1 + rates)\namounts\n\n[1]  958.7165 1049.6874 1070.9376\n\n\nIf we use the vector rates, we obtain some amounts but these are not the values that we are looking for.\nWhat if we vectorize both rates and years 1:3?\n\n# vectorized attempt 2\namounts = amount0 * (1 + rates)^(1:3)\namounts\n\n[1]  958.7165 1101.8437 1228.2661\n\n\nOnce again, we obtain some amounts but these are not the values that we are looking for.\nCan you see why the above vectorized code options fail to capture the correct compounding return?\n\n\n13.2.2 Investing during ten years\nLet’s expand our time horizon from three to ten years, generating random rates of return for each year, and calculating a simulated amount year by year:\n\nset.seed(345)   # for replication purposes\namount0 = 1000\nrates = rnorm(n = 10, mean = 0.10, sd = 0.18)\n\namount1 = amount0 * (1 + rates[1])\namount2 = amount1 * (1 + rates[2])\namount3 = amount2 * (1 + rates[3])\namount4 = amount3 * (1 + rates[4])\namount5 = amount4 * (1 + rates[5])\namount6 = amount5 * (1 + rates[6])\namount7 = amount6 * (1 + rates[7])\namount8 = amount7 * (1 + rates[8])\namount9 = amount8 * (1 + rates[8])\namount10 = amount9 * (1 + rates[10])\n\nNote: we know that this is too repetitive, time consuming, boring and error prone. Can you spot the error?"
  },
  {
    "objectID": "5-04-for-loop.html#iterations-to-the-rescue",
    "href": "5-04-for-loop.html#iterations-to-the-rescue",
    "title": "13  Iterations: For Loop",
    "section": "13.3 Iterations to the Rescue",
    "text": "13.3 Iterations to the Rescue\nLet’s first write some “inefficient” code in order to understand what is going on at each step.\n\namount1 = amount0 * (1 + rates[1])\namount2 = amount1 * (1 + rates[2])\namount3 = amount2 * (1 + rates[3])\namount4 = amount3 * (1 + rates[4])\n# etc\n\n\nWhat do these commands have in common?\n\nThey all take an input amount, that gets compounded for one year at a certain rate. The output amount at each step is used as the input for the next amount.\nInstead of calculating a single amount at each step, we can start with an almost “empty” vector amounts(). This vector will contain the initial amount, as well as the amounts at the end of every year.\n\nset.seed(345)    # for replication purposes\namount0 = 1000\nrates = rnorm(n = 10, mean = 0.10, sd = 0.18)\n\n# output vector (to be populated)\namounts = c(amount0, double(length = 10))\n\n# repetitive commands\namounts[2] = amounts[1] * (1 + rates[1])\namounts[3] = amounts[2] * (1 + rates[2])\n# etc ...\namounts[10] = amounts[9] * (1 + rates[9])\namounts[11] = amounts[10] * (1 + rates[10])\n\nFrom the commands in the previous code chunk, notice that at step s, to compute the next value amounts[s+1], we do this:\namounts[s+1] = amounts[s] * (1 + rates[s])\nThis operation is repeated 10 times (one for each year). At the end of the computations, the vector amounts contains the initial investment, and the 10 values resulting from the compound return year-by-year."
  },
  {
    "objectID": "5-04-for-loop.html#for-loop-example",
    "href": "5-04-for-loop.html#for-loop-example",
    "title": "13  Iterations: For Loop",
    "section": "13.4 For Loop Example",
    "text": "13.4 For Loop Example\nOne programming structure that allows us to write code for carrying out these repetitive steps is a for loop, which is one of the iterative control flow structures in every programming language.\nIn R, a for() loop has the following syntax\n\nfor (s in 1:10) {\n  amounts[s+1] = amounts[s] * (1 + rates[s])\n}\n\n\nYou use the for statement\nInside parenthesis, you specify three ingredients separated by blank spaces:\n\nan auxiliary iterator, e.g. s\nthe keyword in\na vector to iterate through, e.g. 1:10\n\nThe code for the repetitive steps gets wrapped inside braces\n\nLet’s take a look at the entire piece of code:\n\nset.seed(345)    # for replication purposes\namount0 = 1000\nrates = rnorm(n = 10, mean = 0.10, sd = 0.18)\n\n# output vector (to be populated)\namounts = c(amount0, double(length = 10))\n\n# for loop\nfor (s in 1:10) {\n  amounts[s+1] = amounts[s] * (1 + rates[s])\n}\n\namounts\n\n [1] 1000.0000  958.7165 1006.3527 1077.7409 1129.1412\n [6] 1228.3298 1211.0918 1129.9604 1590.9151 2223.8740\n[11] 3170.9926\n\n\nThere are a couple of important things worth noticing:\n\nYou don’t need to declare or create the auxiliary iterator outside the loop\nR will automatically handle the auxiliary iterator (no need to explicitly increase its value)\nThe length of the “iterations vector” determines the number of times the code inside the loop has to be repeated\nYou use for loops when you know how many times a series of calculations need to be repeated.\n\nHaving obtained the vector of amounts, we can then plot a timeline to visualize the behavior of the simulated returns against the hypothetical investment with a constant rate of return:\n\n# random annual rates of return (blue)\nplot(0:10, amounts, type = \"l\", lwd = 2, col = \"blue\",\n     xlab = \"years\", ylab = \"amount (dollars)\", las = 1)\npoints(0:10, amounts, col = \"blue\", pch = 20)\n\n# assuming constant 10% annual return (orange)\nlines(0:10, amount0 * (1+0.10)^(0:10), col = \"orange\", lwd = 2)\npoints(0:10, amount0 * (1+0.10)^(0:10), col = \"orange\", pch = 20)"
  },
  {
    "objectID": "5-04-for-loop.html#about-for-loops",
    "href": "5-04-for-loop.html#about-for-loops",
    "title": "13  Iterations: For Loop",
    "section": "13.5 About For Loops",
    "text": "13.5 About For Loops\nTo describe more details about for loops in R, let’s consider a super simple example. Say you have a vector vec <- c(3, 1, 4), and suppose you want to add 1 to every element of vec. You know that this can easily be achieved using vectorized code:\n\nvec <- c(3, 1, 4) \n\nvec + 1\n\n[1] 4 2 5\n\n\nIn order to learn about loops, I’m going to ask you to forget about the notion of vectorized code in R. That is, pretend that R does not have vectorized functions.\nThink about what you would need to do in order to add 1 to the elements in vec. This addition would involve taking the first element in vec and add 1, then taking the second element in vec and add 1, and finally the third element in vec and add 1, something like this:\n\nvec[1] + 1\nvec[2] + 1\nvec[3] + 1\n\nThe code above does the job. From a purely arithmetic standpoint, the three lines of code reflect the operation that you would need to carry out to add 1 to all the elements in vec.\nFrom a programming point of view, you are performing the same type of operation three times: selecting an element in vec and adding 1 to it. But there’s a lot of (unnecessary) repetition.\nThis is where loops come very handy. Here’s how to use a for () loop to add 1 to each element in vec:\n\nvec <- c(3, 1, 4)\n\nfor (j in 1:3) {\n  print(vec[j] + 1)\n}\n\n[1] 4\n[1] 2\n[1] 5\n\n\nIn the code above we are taking each element vec[j], adding 1 to it, and printing the outcome with print() so that we can visualize the additions at each iteration of the loop.\nWhat if you want to create a vector vec2, in which you store the values produced at each iteration of the loop? Here’s one possibility:\n\nvec <- c(3, 1, 4)  # you can change these values\nvec2 <- rep(0, length(vec))  # vector of zeros to be filled in the loop\n\nfor (j in 1:3) {\n  vec2[j] = vec[j] + 1\n}\n\n\n13.5.1 Anatomy of a For Loop\nThe anatomy of a for loop is as follows:\n\nfor (iterator in times) { \n  do_something\n}\n\nfor() takes an iterator variable and a vector of times to iterate through. For example, in the following code the auxiliary iterator is i and the vector of times is the numeric sequence 1:5.\n\nvalue <- 2\n\nfor (i in 1:5) { \n  value <- value * 2 \n  print(value)\n}\n\n[1] 4\n[1] 8\n[1] 16\n[1] 32\n[1] 64\n\n\nAs you can tell, print() is used to display the updated value at each iteration. This print statement is used here for illustration purposes; in practice you rarely need to print any output in a loop.\nThe vector of times does NOT have to be a numeric vector; it can be any vector. The important thing about this vector is its length, which R uses to determine the number of iterations in the for loop.\n\nvalue <- 2\ntimes <- c('one', 'two', 'three', 'four')\n\nfor (i in times) { \n  value <- value * 2 \n  print(value)\n}\n\n[1] 4\n[1] 8\n[1] 16\n[1] 32\n\n\nHowever, if the iterator is used inside the loop in a numerical computation, then the vector of times will almost always be a numeric vector:\n\nset.seed(4321)\nnumbers <- rnorm(5)\n\nfor (h in 1:length(numbers)) {\n  if (numbers[h] < 0) {\n    value <- sqrt(-numbers[h])\n  } else {\n    value <- sqrt(numbers[h])\n  }\n  print(value)\n}\n\n[1] 0.6532667\n[1] 0.4728761\n[1] 0.8471168\n[1] 0.9173035\n[1] 0.3582698\n\n\n\n\n13.5.2 For Loops and Next statement\nSometimes we need to skip a certain iteration if a given condition is met, this can be done with the next statement\n\nfor (iterator in times) { \n  expr1\n  expr2\n  if (condition) {\n    next\n  }\n  expr3\n  expr4\n}\n\nExample:\n\nx <- 2\nfor (i in 1:5) {\n  y <- x * i\n  if (y == 8) {\n    next\n  }\n  print(y)\n}\n\n[1] 2\n[1] 4\n[1] 6\n[1] 10\n\n\n\n\n13.5.3 For Loops and Break statement\nIn addition to skipping certain iterations, sometimes we need to stop a loop from iterating if a given condition is met, this can be done with the break statement:\n\nfor (iterator in times) { \n  expr1\n  expr2\n  if (stop_condition) {\n    break\n  }\n  expr3\n  expr4\n}\n\nExample:\n\nx <- 2\nfor (i in 1:5) {\n  y <- x * i\n  if (y == 8) {\n    break\n  }\n  print(y)\n}\n\n[1] 2\n[1] 4\n[1] 6\n\n\n\n\n13.5.4 Nested Loops\nIt is common to have nested loops\n\nfor (iterator1 in times1) { \n  for (iterator2 in times2) {\n    expr1\n    expr2\n    ...\n  }\n}\n\n\nExample: Nested loops\nConsider a matrix with 3 rows and 4 columns\n\n# some matrix\nA <- matrix(1:12, nrow = 3, ncol = 4)\nA\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n\n\nSuppose you want to transform those values less than 6 into their reciprocals (that is, dividing them by 1). You can use a pair of embedded loops: one to traverse the rows of the matrix, the other one to traverse the columns of the matrix:\n\n# reciprocal of values less than 6\nfor (i in 1:nrow(A)) { \n  for (j in 1:ncol(A)) {\n    if (A[i,j] < 6) A[i,j] <- 1 / A[i,j] \n  }\n}\nA\n\n          [,1] [,2] [,3] [,4]\n[1,] 1.0000000 0.25    7   10\n[2,] 0.5000000 0.20    8   11\n[3,] 0.3333333 6.00    9   12\n\n\n\n\n\n13.5.5 About for Loops and Vectorized Computations\n\nR loops have a bad reputation for being slow.\nExperienced users will tell you: “tend to avoid for loops in R” (me included).\nIt is not really that the loops are slow; the slowness has more to do with the way R handles the boxing and unboxing of data objects, which may be a bit inefficient.\nR provides a family of functions that are usually more efficient than loops (i.e. apply() functions).\nIf you have NO programming experience, you should ignore any advice about avoiding loops in R.\nYou should learn how to write loops, and understand how they work; every programming language provides some type of loop structure.\nIn practice, many (programming) problems can be tackled using some loop structure.\nWhen using R, you may need to start solving a problem using a loop. Once you solved it, try to see if you can find a vectorized alternative.\nIt takes practice and experience to find alternative solutions to for loops.\nThere are cases when using for loops is not that bad."
  },
  {
    "objectID": "5-05-while-loop.html",
    "href": "5-05-while-loop.html",
    "title": "14  Iterations: While Loop",
    "section": "",
    "text": "In the previous chapter you got introduced to your first iterative construct: for loops. You use this type of loop when you know how many times a given computation needs to be repeated. But what about those situations in which you have to repeat a process without necessarily knowing how many times this repetition will take place? This is where we need a more general type of loop, namely, the while loop."
  },
  {
    "objectID": "5-05-while-loop.html#motivation",
    "href": "5-05-while-loop.html#motivation",
    "title": "14  Iterations: While Loop",
    "section": "14.1 Motivation",
    "text": "14.1 Motivation\nLet’s begin with the same toy example discussed in the previous chapter. Say you have a vector vec <- c(3, 1, 4), and suppose you want to obtain a new vector vec2 that adds 1 to every element in vec. You know that this can easily be achieved using vectorized code:\n\nvec <- c(3, 1, 4) \n\nvec2 <- vec + 1\nvec2\n\n[1] 4 2 5\n\n\nAgain, in order to explain the concept of a while loop, I am going to ask you to pretend that R does not have vectorized code.\nWhat would you need to do in order to add 1 to the elements in vec? As we mentioned in the preceding chapter, you would need to do something like this:\n\n# new vector to be updated\nvec2 <- rep(0, 3)\n\n# repetitive steps\nvec2[1] <- vec[1] + 1\nvec2[2] <- vec[2] + 1\nvec2[3] <- vec[3] + 1\n\nThat is, take the first element in vec and add 1, then take the second element in vec and add 1, and finally the third element in vec and add 1. Basically, you are performing the same type of operation several times: selecting an element in vec and adding 1 to it. But there’s a lot of (unnecessary) repetition.\nWe’ve seen how to write a for loop to take care of the addition computation. Alternatively, we can also approach this problem from a slightly different perspective by considering a stopping condition to decide when to terminate the repetitive process of adding 1 to the elements in vec.\nWhat stopping condition can we use? Well, one example may involve: “let’s keep selecting a single element in vec and adding 1 to it, until we exhaust all elements in vec”. In other words, let’s keep iterating until we reach the last element in vec.\nAs usual, the first step involves identifying the common structure of the repetitive steps. We can make the repetitive code a bit more general by referring to each position as pos:\n\nvec2[pos] <- vec[pos] + 1\n\nOnce we have the correct abstraction for the code that needs to be repetead, then we can encapsulate it with a while loop. Let me first show you an example and then we’ll examine it in detail:\n\n# input vector\nvec <- c(3, 1, 4)\n\n# initialize output vector\nvec2 <- rep(0, 3)\n\n# declare auxiliary iterator\npos <- 1\n\n# while loop\nwhile (pos <= length(vec)) {\n  vec2[pos] <- vec[pos] + 1\n  pos <- pos + 1  # update iterator\n}\n\nThe first thing that I should mention is that writing an R while loop is a bit more complex than writing a for loop. The complexity has to do with some of the things that R does not automatically take care of in a while loop.\nOne main difference between a for loop and a while loop is that in the latter we must explicit declare the auxiliary iterator and give it an initial value: pos <- 1.\nNext we have the while statement. This statement is technically a function, but I prefer to think of it, and call it, a statement (like the if and the for statements). What you pass inside parenthesis of the while declaration is a condition. This is basically any piece of code that R will evaluate and coerce it into a logical condition that is TRUE or FALSE. The while loop iterates as long as the condition is TRUE. If the condition becomes FALSE then the loop is terminated.\nThe code of the repetitive steps consists of an R expression { ... }. This is where we indicate what to do at each step. Often, an important piece of code that we need to include here involves increasing the value of the auxiliary iterator: pos <- pos + 1. In this particular example, if we don’t increase the iterator pos, the loop would iterate forever.\nNote that the condition is the stopping condition, which in turn depends on the auxiliary iterator: pos <= length(vec). You can think of this condition as: “let’s keep iterating until we reach the last element in vec”."
  },
  {
    "objectID": "5-05-while-loop.html#anatomy-of-a-while-loop",
    "href": "5-05-while-loop.html#anatomy-of-a-while-loop",
    "title": "14  Iterations: While Loop",
    "section": "14.2 Anatomy of a While Loop",
    "text": "14.2 Anatomy of a While Loop\nNow that you’ve seen a first example of a while loop, I can give you a generic template for this kind of iterative construct:\n\niterator <- initial\n\nwhile (condition) {\n  do_something\n  iterator <- iterator + 1\n}\n\nWhat’s going on?\n\nyou need to declare the auxiliary iterator with some initial value\nyou declare the while statement by giving a condition inside parenthesis\nthe condition must be a piece of code that gets evaluated into a single logical value: TRUE or FALSE\nthe condition is used as the stopping condition: if the condition is TRUE the loop keeps iterating; when the condition becomes FALSE the loop is terminated\nwe use an R compound expression { ... } to embrace the code that will be repeated at each iteration\ninside the loop, you typically need to increase the value of the iterator; even if the condition does not depend on the iterator, it’s a good idea to keep track of the number of iterations in the loop"
  },
  {
    "objectID": "5-05-while-loop.html#another-example",
    "href": "5-05-while-loop.html#another-example",
    "title": "14  Iterations: While Loop",
    "section": "14.3 Another Example",
    "text": "14.3 Another Example\nLet’s see a more interesting example.\nSay we generate a vector with 10 different integer numbers between 1 and 100, arranged in increasing order. To make things more interesting, we are going to generate these numbers in a random way using the sample.int() function that allows us to get a random sample of size = 10 integers, sampling without replacement (replace = FALSE):\n\nset.seed(234)  # for replication purposes\n\n# vector of 10 random integers between 1 and 100\nrandom_numbers = sample.int(n = 100, size = 10, replace = FALSE)\nrandom_numbers = sort(random_numbers)\nrandom_numbers\n\n [1]  1 18 31 34 46 56 68 92 97 98\n\n\nWhat are we going to do with these random_numbers? We are going to compute a cumulative sum until its value becomes greater than 100. And we are going to consider these two questions:\n\nWhat is the value of the cumulative sum?\nHow many numbers were added to reach the sum’s value?\n\nMy recommendation is to always start with baby steps. Simply put, start writing code for a couple of concrete steps so that you understand what kind of computations will be repeated, and what things they have in common:\n\n# initialize output sum\ntotal_sum = 0\n\n# accumulate numbers\ntotal_sum = total_sum + random_numbers[1]\ntotal_sum = total_sum + random_numbers[2]\ntotal_sum = total_sum + random_numbers[3]\n# ... keep adding numbers as long as total_sum <= 100\n\nThere are three important aspects to keep in mind:\n\nwe need an object to store the cumulative sum: total_sum\nwe need an iterator to move through the elements of random_numebrs\nand of course we need to determine a stopping-condition: total_sum <= 100\n\nHere’s the code:\n\n# initialize object of cumulative sum\ntotal_sum = 0\n\n# declare iterator\npos = 0\n\n# repetitive steps\nwhile (total_sum <= 100) {\n  pos = pos + 1\n  total_sum = total_sum + random_numbers[pos]\n}\n\n# what is the value of the cumulative sum?\ntotal_sum\n\n[1] 130\n\n# how many iterations were necessary?\npos\n\n[1] 5\n\n\nObserve that in this example, we declared pos = 0. Then, at each iteration, we increase its value pos = pos + 1, and then we added random_numbers[pos] to the previous total_sum value, effectively updating the cumulative sum.\nFor comparison purposes, consider this other while loop. It looks extremely similar to the preceding loop but there is an important difference.\n\n# initialize object of cumulative sum\ntotal_sum = 0\n\n# declare iterator\npos = 1\n\n# repetitive steps\nwhile (total_sum <= 100) {\n  total_sum = total_sum + random_numbers[pos]\n  pos = pos + 1\n}\n\n# what is the value of the cumulative sum?\ntotal_sum\n\n[1] 130\n\n# how many iterations were necessary?\npos\n\n[1] 6\n\n\nCan you see the difference between these two while loops?\nIn this second loop, the iterator is declared as pos = 1, and its value is increased after updating the cumulative sum. While total_sum has the correct value, pos does not indicate anymore the right number of iterations.\nI wanted to show you this second example to make a point: in a while loop you not only need to declare the iterator before entering the loop, but you also need to carefully think what initial value you’ll use, as well as when to increase its value inside the loop. Some times the very first thing to do in each iteration is to increase the value of the iterator; some times that’s the last thing to do. It all depends on the specific way you are approaching a given iterative task.\n\n14.3.1 While Loops and Next statement\nSometimes we need to skip a certain iteration if a given condition is met, this can be done with the next statement. The following code chunk contains an abstract template that uses next:\n\niterator <- initial\n\nwhile (condition) {\n  do_something\n  if (skip_condition) {\n    next\n  }\n  iterator <- iterator + 1\n}\n\nAs a less abstract example, let’s bring back the while loop of the cumulative sum of random numbers, but this time say we want to skip any numbers between 30 and 39. This means we need an if-else statement to check whether a given element of random_numbers is between 30 and 39. If yes, we should skip that element and go to the next iteration. Here is how to do it:\n\ntotal_sum = 0\npos = 0\n\nwhile (total_sum <= 100) {\n  pos = pos + 1\n  if (random_numbers[pos] %in% 30:39) {\n    next\n  }\n  total_sum = total_sum + random_numbers[pos]\n}\n\ntotal_sum\n\n[1] 121\n\npos\n\n[1] 6\n\n\n\n\n14.3.2 While Loops and Break statement\nIn addition to skipping certain iterations, sometimes we need to stop a loop from iterating if a given condition is met. This can be done with the break statement, which is shown below in an abstract code template:\n\nwhile (condition) { \n  expr1\n  expr2\n  if (stop_condition) {\n    break\n  }\n  expr3\n  expr4\n}\n\nLet’s go back to the cumulative sum example. Say we want to stop iterating if numbers are greater than or equal to 40. Like we did previously, we need again an if-else statement to check whether a given element of random_numbers is greater than or equal to 40. If yes, we stop the loop from iterating by using the break statement as follows:\n\ntotal_sum = 0\npos = 0\n\nwhile (total_sum <= 100) {\n  pos = pos + 1\n  if (random_numbers[pos] >= 40) {\n    break\n  }\n  total_sum = total_sum + random_numbers[pos]\n}\n\ntotal_sum\n\n[1] 84\n\npos\n\n[1] 5"
  },
  {
    "objectID": "5-06-more-functions.html",
    "href": "5-06-more-functions.html",
    "title": "15  More About Functions",
    "section": "",
    "text": "In this chapter you will learn more aspects about creating functions in R."
  },
  {
    "objectID": "5-06-more-functions.html#functions-recap",
    "href": "5-06-more-functions.html#functions-recap",
    "title": "15  More About Functions",
    "section": "15.1 Functions Recap",
    "text": "15.1 Functions Recap\nConsider a toy example with a function that squares its argument:\n\nsquare = function(x) {\n  x * x\n}\n\n\nthe function name is \"square\"\nit has one argument: x\nthe function body consists of one simple expression\nit returns the value x * x\n\nsquare() works like any other function in R:\n\nsquare(10)\n\n[1] 100\n\n\nIn this case, square() is also vectorized:\n\nsquare(1:5)\n\n[1]  1  4  9 16 25\n\n\nWhy is square() vectorized?\nOnce defined, functions can be used in other function definitions:\n\nsum_of_squares = function(x) {\n  sum(square(x))\n}\nsum_of_squares(1:5)\n\n[1] 55\n\n\n\n15.1.1 Simple Expressions\nFunctions with a body consisting of a simple expression can be written with no braces (in one single line!):\n\nsquare = function(x) x * x\nsquare(10)\n\n[1] 100\n\n\nHowever, as a general coding rule, you should get into the habit of writing functions using braces.\n\n\n15.1.2 Nested Functions\nWe can also define a function inside another function:\n\ngetmax = function(a) {\n  # nested function\n  maxpos <- function(u) which.max(u) \n  # output\n  list(position = maxpos(a),\n       value = max(a))\n}\ngetmax(c(2, -4, 6, 10, pi))\n\n$position\n[1] 4\n\n$value\n[1] 10"
  },
  {
    "objectID": "5-06-more-functions.html#function-output",
    "href": "5-06-more-functions.html#function-output",
    "title": "15  More About Functions",
    "section": "15.2 Function Output",
    "text": "15.2 Function Output\nThe value of a function can be established in two ways:\n\nAs the last evaluated simple expression (in the body of the function)\nAn explicitly returned value via return()\n\nHere’s a basic example of a function in which the output is the last evaluated expression:\n\nadd = function(x, y) {\n  x + y\n}\n\nadd(2, 3)\n\n[1] 5\n\n\nHere’s another version of add() in which the output is the last evaluated expression:\n\nadd = function(x, y) {\n  z = x + y\n  z\n}\n\nadd(2, 3)\n\n[1] 5\n\n\nBe careful with the form in which the last expression is evaluated:\n\nadd = function(x, y) {\n  z = x + y\n}\n\nadd(2, 3)\n\nIn this case, it looks like add() does not work. If you run the previous code, nothing appears in the console. Can you guess why? To help you answer this question, assign the invocation to an object and then print the object:\nwhy <- add(2, 3)\nwhy\nadd() does work. The issue has to do with the form of the last expression. Nothing gets displayed in the console because the last statement z <- x + y is an assignment (that does not print anything).\n\n15.2.1 The return() command\nMore often than not, the return() command is included to explicitly indicate the output of a function:\n\nadd = function(x, y) {\n  z <- x + y\n  return(z)\n}\n\nadd(2, 3)\n\n[1] 5\n\n\nI’ve seen that many users with previous programming experience in other languages prefer to use return(). The main reason is that most programming languages tend to use some sort of return statement to indicate the output of a function.\nSo, following good language-agnostic coding practices, we also recommend that you use the function return(). In this way, any reader can quickly scan the body of your functions and visually locate the places in which a return statement is being made.\n\n\n15.2.2 White Spaces\n\nUse a lot of it\naround operators (assignment and arithmetic)\nbetween function arguments and list elements\nbetween matrix/array indices, in particular for missing indices\nSplit long lines at meaningful places\n\nAvoid this\n\na<-2\nx<-3\ny<-log(sqrt(x))\n3*x^7-pi*x/(y-a)\n\nMuch Better\n\na <- 2\nx <- 3\ny <- log(sqrt(x))\n3*x^7 - pi * x / (y - a)\n\nAnother example:\n\n# Avoid this\nplot(x,y,col=rgb(0.5,0.7,0.4),pch='+',cex=5)\n\n# okay\nplot(x, y, col = rgb(0.5, 0.7, 0.4), pch = '+', cex = 5)\n\nAnother readability recommendation is to limit the width of line: they should be broken/wrapped around so that they are less than 80 columns wide\n\n# lines too long\nhistogram <- function(data){\nhist(data, col = 'gray90', xlab = 'x', ylab = 'Frequency', main = 'Histogram of x')\nabline(v = c(min(data), max(data), median(data), mean(data)),\ncol = c('gray30', 'gray30', 'orange', 'tomato'), lty = c(2,2,1,1), lwd = 3)\n}\n\nLines should be broken/wrapped around so that they are less than 80 columns wide\n\n# lines with okay width\nhistogram <- function(data) {\n  hist(data, col = 'gray90', xlab = 'x', ylab = 'Frequency', \n       main = 'Histogram of x')\n  abline(v = c(min(data), max(data), median(data), mean(data)),\n         col = c('gray30', 'gray30', 'orange', 'tomato'), \n         lty = c(2,2,1,1), lwd = 3)\n}\n\n\nSpacing forms the second important part in code indentation and formatting.\nSpacing makes the code more readable\nFollow proper spacing through out your coding\nUse spacing consistently\n\n\n# this can be improved\nstats <- c(min(x), max(x), max(x)-min(x),\n  quantile(x, probs=0.25), quantile(x, probs=0.75), IQR(x),\n  median(x), mean(x), sd(x)\n)\n\nDon’t be afraid of splitting one long line into individual pieces:\n\n# much better\nstats <- c(\n  min(x), \n  max(x), \n  max(x) - min(x),\n  quantile(x, probs = 0.25),\n  quantile(x, probs = 0.75),\n  IQR(x),\n  median(x), \n  mean(x), \n  sd(x)\n)\n\nYou can even do this:\n\n# also OK\nstats <- c(\n  min    = min(x), \n  max    = max(x), \n  range  = max(x) - min(x),\n  q1     = quantile(x, probs = 0.25),\n  q3     = quantile(x, probs = 0.75),\n  iqr    = IQR(x),\n  median = median(x), \n  mean   = mean(x), \n  stdev  = sd(x)\n)\n\n\nAll commas and semicolons must be followed by single whitespace\nAll binary operators should maintain a space on either side of the operator\nLeft parenthesis should start immediately after a function name\nAll keywords like if, while, for, repeat should be followed by a single space.\n\nAll binary operators should maintain a space on either side of the operator\n\n# NOT Recommended \na=b-c\na = b-c\na=b - c; \n\n# Recommended \na = b - c\n\nAll binary operators should maintain a space on either side of the operator\n\n# Not really recommended \nz <- 6*x + 9*y\n\n# Recommended (option 1)\nz <- 6 * x + 9 * y\n\n# Recommended (option 2)\nz <- (7 * x) + (9 * y)\n\nLeft parenthesis should start immediately after a function name\n\n# NOT Recommended \nread.table ('data.csv', header = TRUE, row.names = 1)\n\n# Recommended \nread.table('data.csv', header = TRUE, row.names = 1)\n\nAll keywords like if, while, for, repeat should be followed by a single space.\n\n# not bad\nif(is.numeric(object)) {\n  mean(object)\n}\n\n# much better\nif (is.numeric(object)) {\n  mean(object)\n}"
  },
  {
    "objectID": "5-06-more-functions.html#indentation",
    "href": "5-06-more-functions.html#indentation",
    "title": "15  More About Functions",
    "section": "15.3 Indentation",
    "text": "15.3 Indentation\n\nKeep your indentation style consistent\nThere is more than one way of indenting code\nThere is no “best” style that everyone should be following\nYou can indent using spaces or tabs (but don’t mix them)\nCan help in detecting errors in your code because it can expose lack of symmetry\nDo this systematically (RStudio editor helps a lot)\n\nDon’t write code like this:\n\n# no indentation\n# Don't do this!\nif(!is.vector(x)) {\nstop('x must be a vector')\n} else {\nif(any(is.na(x))){\nx <- x[!is.na(x)]\n}\ntotal <- length(x)\nx_sum <- 0\nfor (i in seq_along(x)) {\n  x_sum <- x_sum + x[i]\n}\nx_sum / total\n}\n\nInstead, write with indentation\n\n# better with indentation\nif (!is.vector(x)) {\n  stop('x must be a vector')\n} else {\n  if (any(is.na(x))) {\n    x <- x[!is.na(x)]\n  }\n  total <- length(x)\n  x_sum <- 0\n  for (i in seq_along(x)) {\n    x_sum <- x_sum + x[i]\n  }\n  x_sum / total\n}\n\nThere are several Indenting Styles\n\n# style 1\nfind_roots <- function(a = 1, b = 1, c = 0) \n{\n  if (b^2 - 4*a*c < 0) \n  {\n    return(\"No real roots\")\n  } else \n  {\n    return(quadratic(a = a, b = b, c = c))\n  }\n}\n\nMy preferred style is like this:\n\n# style 2\nfind_roots <- function(a = 1, b = 1, c = 0) {\n  if (b^2 - 4*a*c < 0) {\n    return(\"No real roots\")\n  } else {\n    return(quadratic(a = a, b = b, c = c))\n  }\n}\n\nBenefits of code indentation:\n\nEasier to read\nEasier to understand\nEasier to modify\nEasier to maintain\nEasier to enhance\n\n\n15.3.1 Meaningful Names\nChoose a consistent naming style for objects and functions\n\nsomeObject (lowerCamelCase)\nSomeObject (UpperCamelCase)\nsome_object (underscore separation)\nsome.object (dot separation)\n\nAvoid using names of standard R objects, for example:\n\nvector\nmean\nlist\ndata\nc\ncolors\n\nIf you’re thinking about using names of R objects, prefer something like this\n\nxvector\nxmean\nxlist\nxdata\nxc\nxcolors\n\nBetter to add meaning like this\n\nmean_salary\ninput_vector\ndata_list\ndata_table\nfirst_last\nsome_colors\n\nPrefer Pronounceable Names\n\n# avoid cryptic abbreviations\nDtaRcrd102 <- list(\n  nm = 'John Doe',\n  bdg = 'Valley Life Sciences Building',\n  rm = 2060\n)\n\n\n# prefer pronounceable names \nCustomer <- list(\n  name = 'John Doe',\n  building = 'Valley Life Sciences Building',\n  room = 2060\n)\n\n\n\n15.3.2 Syntax: Parentheses\nUse parentheses for clarity even if not needed for order of operations.\n\na <- 2\nx <- 3\ny <- 4\n\na/y*x\n\n# better\n(a / y) * x\n\nanother example\n\n# confusing\n1:3^2\n\n[1] 1 2 3 4 5 6 7 8 9\n\n# better\n1:(3^2)\n\n[1] 1 2 3 4 5 6 7 8 9"
  },
  {
    "objectID": "5-06-more-functions.html#recommendations",
    "href": "5-06-more-functions.html#recommendations",
    "title": "15  More About Functions",
    "section": "15.4 Recommendations",
    "text": "15.4 Recommendations\n\nFunctions are tools and operations\nFunctions form the building blocks for larger tasks\nFunctions allow us to reuse blocks of code easily for later use\nUse functions whenever possible\nTry to write functions rather than carry out your work using blocks of code\nDon’t write long functions\nIdeal length between 2 and 4 lines of code\nNo more than 10 lines\nShould not exceed the size of the text editor window\nFunctions shouldn’t be longer than one visible screen (with reasonable font)\nRewrite long functions by converting collections of related expression into separate functions\nSmaller functions are easier to debug, easier to understand, and can be combined in a modular fashion\nSeparate small functions\nSmaller functions are easier to reason about and manage\nSmaller functions are easier to test and verify they are correct\nSmaller functions are more likely to be reusable\nThink about different scenarios and contexts in which a function might be used\nCan you generalize it?\nWho will use it?\nWho is going to maintain the code?\nUse descriptive names\nReaders (including you) should infer the operation by looking at the call of the function\nbe modular (having a single task)\nhave meaningful name\nhave a comment describing their purpose, inputs and outputs\nFunctions should not modify global variables\nexcept connections or environments\nshould not change global par() settings"
  },
  {
    "objectID": "6-01-connections.html",
    "href": "6-01-connections.html",
    "title": "16  Introduction",
    "section": "",
    "text": "This part of the book is dedicated to describe the various mechanisms available in R to import and export “data” and other “resources”. Here I’m using the term “resources” in an informal sense to refer to various types of files such as script files, binary files, text files, image files, and things like that. Likewise, I’m using the term “data” in a loosely way to indicate R data objects (e.g. vectors, arrays, lists, data-frames), graphics, code, as well as content of any kind of file.\nYou should know upfront that there’s a wide range of ways and options to import/export “data” in R. To go beyond the topics discussed in the book, and to know more about many of the technicalities behind importing and exporting resources in R, the authoritative document to look at is the manual R Data Import/Export available at:\nhttps://cran.r-project.org/doc/manuals/r-release/R-data.html"
  },
  {
    "objectID": "6-01-connections.html#importing-and-exporting-resources",
    "href": "6-01-connections.html#importing-and-exporting-resources",
    "title": "16  Introduction",
    "section": "16.1 Importing and Exporting Resources",
    "text": "16.1 Importing and Exporting Resources\nR has a large number of functions and packages to import and to export a wide variety of resources and files (e.g. script files, binary files, text files, image files).\nIn the following figure, I’m depicting a conceptual diagram to show a couple of common examples for importing and exporting some resources.\n\n\n\n\n\nConceptual diagram illustrating some importing and exporting resources.\n\n\n\n\nPerhaps the most common type of importing operation is when we have some data table that we want to read in. For instance, we may have a data file called table.csv, located in our session’s working directory. Assuming that the format of this file is a comma-separated-value (CSV), we could try to import it in R with the help of the read.csv() function:\n\n# hypothetical data-table importing example\ndat = read.csv(file = \"table.csv\")\n\nLikewise, we could have one or more functions in an R script file called script.R that we want to import. Assuming that this file is also in our session’s working directory, we could use the function source() to source-in such functions:\n\n# hypothetical R-script importing example\nsource(file = \"script.R\")\n\nWhat about exporting resources from R to some external resource? For example, consider a typical situation in which we have a data object, say a data frame, called tbl that we want to export into a text file. To be more precise, say we want to export the data frame tbl to a CSV file called output.csv to be located in our session’s directory. In this case, we may want to use the function write.csv()\n\n# hypothetical data-table exporting example\nwrite.csv(x = tbl, file = \"output.csv\")\n\n\n16.1.1 Behind import/export functions\nBefore I tell you more about some of the common—and not so common—import and export operations available in R, I first need to take you down a rabbit hole to explain some technicalities behind the related functions for importing and exporting resources in R.\nWhen importing information from an external file, we need to use a certain data-import function, e.g. read.table(), readLines(), scan(), etc. As you might expect, each data-import function has specific arguments that let you choose further options for how R should handle this task. Despite their different arguments, all these functions have one thing in common which is the mandatory argument: the name of the input file.\nThe same thing can be said about the data-export functions such as write.table(), writeLines(), cat(), png(), etc. Even though each of these functions differs in its structure and arguments, they all have one thing in common: the mandatory argument consisting of the name of the output file.\nThe figure below illustrates both types of generic situations: importing from an input file, and exporting to an output file. In this diagram, I’m using the names import() and export() as generic labels for data-import and data-export functions.\n\n\n\n\n\nConceptual diagram illustrating generic import and export tasks.\n\n\n\n\nAs I said, the primary argument to the import and export functions is the “name” of the external file. Here the term “name” refers to the file path. In other words, the “name” is not just the name of the file but also its location on the file-system where the file is located.\nThe external file can be located in your computer or somewhere else, like in the “cloud”, which at the end of the day it’s going to be another computer remotely located.\nAnother thing to notice in the diagram has to do with the so-called connections. What I’m trying to indicate in the diagram is that all import and export functions use—under the hood—an internal connection() function which plays a fundamental role in this type of operations. What is a connection? Let’s find out."
  },
  {
    "objectID": "6-01-connections.html#connections",
    "href": "6-01-connections.html#connections",
    "title": "16  Introduction",
    "section": "16.2 Connections",
    "text": "16.2 Connections\nIn order for R to be able to import external resources (e.g. data files, script files, image files), it needs to have a way to communicate with the outside world. The same applies to any resource-exporting activity: R needs to open its doors to let resources enter and exit its territory.\nThe mechanism used by R to establish channels of communication with the outside world is given by the so-called connections. To explain this concept let me give you an analogy.\nIn this analogy I’m going to play the role of R. My family, friends, coworkers and students will play the generic role of resources. For example, if I want to communicate with my teaching assistants (TA), I need a mechanism to reach out to them. One way to communicate with my TAs could be talking to them in-person. Another way of communication could be via email (or old-fashion mail). Another possibility may involve me sending them a text-message, or maybe calling them by phone. In summary, there are several ways for me to connect with my TAs. This is precisely the main idea behind R connections.\nFormally speaking, a connection is the mechanism used by R to establish a line of communication to external resources or files. Technically, connections are implemented by a set of functions, such as file(), url(), and gzfile()—to mention but a few—that allow us to create, open and close connections. You can find more information about these functions in their help documentation page:\nhelp(connections)\nLet’s go back to my analogy. Say I want to reach out to one of my teaching assistants, and I decide to communicate with a text message sent from my cellphone. In this case we can say that the connection consists of sending a text message. If you think about this exporting operation I need to:\n\nuse a text-messaging application; this would be the equivalent of an export() function\nspecify the phone number to which my message will be sent; this would be the equivalent of the file path\nwrite the content of the message; this would be the equivalent of the “data” to be exported\n\nNow, the text-messaging application will take the phone number and “do its magic” to send my message. This “magical” part is the equivalent of the internal connection function.\nIt turns out that you rarely need to explicitly call any of the connection functions in R. If you were using other programming languages, chances are you may very well need to explicitly call a connection function (or its equivalent) to tell the program the kind of operation that you want to perform: for instance open a file in reading mode, or open a file in writing mode, or closing a file. Most of the time in R, though, we don’t need to specify this kind of low-level communication.\nSo why bother talking about connections?\nI just want you to know that behind any function that allows you to import from a file, and export to a file, there is a connection function. Typically you don’t need to do anything with these internal functions. But if you want or need to take full control over all the details in an importing/exporting operation, connection functions are there for you."
  },
  {
    "objectID": "6-02-import-tables.html",
    "href": "6-02-import-tables.html",
    "title": "17  Importing Data Tables",
    "section": "",
    "text": "The most common type of data-import operation in R has to do with importing data tables. Because of this, I have decided to exclusively dedicate this chapter to review this type of operation. In a nutshell, I describe various standard ways to import tabular data. By “standard” I mean using base functions such as read.table() and friends. This is in contrast to alternative functions from packages such as \"readr\", and other packages."
  },
  {
    "objectID": "6-02-import-tables.html#motivation",
    "href": "6-02-import-tables.html#motivation",
    "title": "17  Importing Data Tables",
    "section": "17.1 Motivation",
    "text": "17.1 Motivation\nSuppose we have data about the accounts of an individual’s portfolio (see table below). There are five different accounts, the type of bank (brick-and-mortar or online) associated to the account, the annual rate of return, and the balance amount (in dollars).\n\n\n\naccount\nbank\nrate\nbalance\n\n\n\n\nsavings\nbrick-n-mortar\n0.020\n1000\n\n\nmoney market\nonline\n0.025\n2000\n\n\ncertificate\nbrick-n-mortar\n0.030\n3000\n\n\nbrokerage\nonline\n0.070\n5000\n\n\nretirement\nonline\n0.050\n9000\n\n\n\nA data table like this one could be stored in various types of files. For example, it could be stored in a Comma Separated Value (CSV) file, which is a very common kind of text file format used to store tables. Another possible way in which this table could be stored is in a spreadsheet (e.g. Excel, Google Sheets, Mac Numbers).\n\n17.1.1 Data in Text Files\nLet’s assume that the table is stored in a text file. Because the term text file is used in slightly different ways, let me be a bit more specific about what I mean by text file:\n\nBy text file I mean a plain text file that can be read and manipulated with a text editor (not to be confused with a word-processor)\nPlain text as an umbrella term for any file that is in a human-readable form, with comon file extensions such as .txt, .csv, .xml, .html.\nText file implying that its content is stored as a sequence of characters\nEach character stored as a single byte of data\nData is arranged in rows, with several values stored on each row"
  },
  {
    "objectID": "6-02-import-tables.html#character-delimited-text-files",
    "href": "6-02-import-tables.html#character-delimited-text-files",
    "title": "17  Importing Data Tables",
    "section": "17.2 Character Delimited Text Files",
    "text": "17.2 Character Delimited Text Files\nA common way to store data tables is via text files. But how is this actually done? How can a data table be stored in a text file?\n\n\n\n\n\nHow are data tables stored in text files?\n\n\n\n\nYou may not have thought about this before. This was certainly the case for me back when I was an undergraduate student. I could perfectly picture a data table in my head, with a bunch of rows and columns forming its grid-like structure. But I never considered a table’s storage format in a text file.\nThink about it: a table is made of cells that come from the intersection of rows and columns. So the two fundamental questions when storing data in a text file are: 1) how to represent rows?, and 2) how to represent columns? Or in other words: how to convey the notion of cells in a text file?\nThe answer to this question comes from realizing what a data cell does. A cell is basically a placeholder for a data value. Cells let us separate or delimit one data value from another. So all we have to do is to come up with a delimiter or separator to differentiate from one data point to the next one. The way this is done is by choosing a certain character as the delimiter. As for the notion of rows, we can simply use newlines.\nHere is an example of how the accounts data table can be store in a text file, using commas \",\" as the character to separate values:\naccount,bank,rate,balance\nsavings,bricknmor,0.020,1000\nmonmarket,online,0.025,2000\ncertificate,bricknmor,0.030,3000\nbrokerage,online,0.070,5000\nretirement,online,0.050,9000\n\n17.2.1 Common Delimiters\nAs you can tell, the idea of storing data tables via text files is very simple and clever. More formally, this storage option is commonly referred to as field-delimiter formats. The term “field” is a synonym of variable or column. The term “delimiter” indicates that a certain character is used to delimit the values of every column.\nCommon examples of such delimiters are blank space characters \" \", tab characters \"\\t\", or comma characters \",\".\n\n\n\nDelimiter\nDescription\n\n\n\n\n\" \"\nwhite space\n\n\n\",\"\ncomma\n\n\n\"\\t\"\ntab\n\n\n\";\"\nsemicolon\n\n\n\nAs a matter of fact, you can come up with your own delimiter. For instance, I can use vertical bars \"|\" as delimiters:\naccount|bank|rate|balance\nsavings|bricknmor|0.020|1000\nmonmarket|online|0.025|2000\ncertificate|bricknmor|0.030|3000\nbrokerage|online|0.070|5000\nretirement|online|0.050|9000\nOr even use double colons as delimiters:\naccount::bank::rate::balance\nsavings::bricknmor::0.020::1000\nmonmarket::online::0.025::2000\ncertificate::bricknmor::0.030::3000\nbrokerage::online::0.070::5000\nretirement::online::0.050::9000\nTo be honest, if you have to choose a certain character for delimiting purposes, I would recommend not to be creative, and instead to stick with one of the conventional delimiters. Below are some examples of what the content of a text file—storing the accounts table—could look like when using different delimiters.\n\nSpace Delimited\nExample of a space delimited file (common file extension .txt)\naccount bank rate balance\nsavings bricknmor 0.020 1000\nmonmarket online 0.025 2000\ncertificate bricknmor 0.030 3000\nbrokerage online 0.070 5000\nretirement online 0.050 9000\n\n\nTab Delimited\nExample of a tab delimited file (common file extensions .txt or .tsv)\naccount   bank    rate    balance\nsavings   bricknmor   0.020   1000\nmonmarket   online    0.025   2000\ncertificate   bricknmor   0.030   3000\nbrokerage   online    0.070   5000\nretirement    online    0.050   9000\n\n\nSemicolon Delimited\nExample of a semicolon delimited file (common file extension .csv)\naccount;bank;rate;balance\nsavings;bricknmor;0.020;1000\nmonmarket;online;0.025;2000\ncertificate;bricknmor;0.030;3000\nbrokerage;online;0.070;5000\nretirement;online;0.050;9000\n\n\n\n17.2.2 Delimiters in Data Values\nWhat happens if the chosen delimiter is actually part of a data value? As an example of this type of situation, let’s modify the accounts data table. In particular, suppose that the values in column balance contain a comma to better distinguish numbers in thousands of dollars:\n\n\n\naccount\nbank\nrate\nbalance\n\n\n\n\nsavings\nbrick-n-mortar\n0.020\n1,000\n\n\nmoney market\nonline\n0.025\n2,000\n\n\ncertificate\nbrick-n-mortar\n0.030\n3,000\n\n\nbrokerage\nonline\n0.070\n5,000\n\n\nretirement\nonline\n0.050\n9,000\n\n\n\nIf commas are also used as delimiters, we will have a conflict because the commas in balance values are not intended to be delimiters:\naccount,bank,rate,balance\nsavings,bricknmor,0.020,1,000\nmonmarket,online,0.025,2,000\ncertificate,bricknmor,0.030,3,000\nbrokerage,online,0.070,5,000\nretirement,online,0.050,9,000\nWhen something like this happens, to avoid a conflict between the delimiting character and its usage as part of a data value, the convention is to surround the values within quotes (typically double quotes), like this:\naccount,bank,rate,balance\nsavings,bricknmor,0.020,\"1,000\"\nmonmarket,online,0.025,\"2,000\"\ncertificate,bricknmor,0.030,\"3,000\"\nbrokerage,online,0.070,\"5,000\"\nretirement,online,0.050,\"9,000\"\n\n\n17.2.3 Fixed-Width Format Files\nIn addition to character-delimited files, there is another kind of plain text format that can also be used to store data tables: the so-called fixed-width formats or fwf for short.\nIn a fixed-width format file, the way in which values are separated is not with a character. Instead, values in a column are given a fixed width expressed in a certain number of characters.\nHere’s an example of a fixed width delimited file (common file extension .txt). For sake of illustration, I’m adding a sequence of digits at the top. In real life, the first line of digits is not supposed to be part of the file.\n12345678901234567890123456789012345\naccount     bank      rate  balance\nsavings     bricknmor 0.020 1000\nmonmarket   online    0.025 2000\ncertificate bricknmor 0.030 3000\nbrokerage   online    0.070 5000\nretirement  online    0.050 9000\nAll the data of the first column account is given a width of 12 characters (i.e. digits 123456789012). In turn, all the data in column bank fits within a width of 10 characters (i.e. digits 3456789012), and so on.\n\n\n17.2.4 Summary\nTo summarize:\n\nA common way to store data in tabular form is via text files\nTo store the data we need a way to separate data values\nEach line represents a “row”\nThe idea of “columns” is conveyed with delimiters\nFields within each line are separated by the delimiter\nQuotation marks are used when the delimiter character occurs within one of the fields"
  },
  {
    "objectID": "6-02-import-tables.html#importing-data-tables",
    "href": "6-02-import-tables.html#importing-data-tables",
    "title": "17  Importing Data Tables",
    "section": "17.3 Importing Data Tables",
    "text": "17.3 Importing Data Tables\nNow that we have talked about how data tables are stored in text files, and the various formats in which this is done, let’s review the set of functions to import tables in R, as well as important considerations to keep in mind when importing data in general.\nConsiderations before importing a data table in R:\n\nWhat is the character used as field delimiter?\nDoes the file contain names of columns?\nDoes the file contain a column for row names?\nAre there any missing values? If yes, how are missing values encoded?\nDo you want to read in all rows, or just some of them?\nDo you want to read in all columns, or just some of them?\nDo you need to convert delimiter characters? (e.g. from space to comma)\nCan you determine the data-type of each column?\nAre there any uninformative numbers?\nCan you convert those uninformative numbers to informative labels?\n\n\n\n\n\n17.3.1 Function read.table() and friends\nThe most common way to read and import tables in R is by using read.table() and friends such as read.csv(), read.delim(), etc. If you take a look at the arguments of read.table() you’ll see that this function has more than 20 of them. Actually, if you inspect the help documentation, read.table() comes with the following usage:\nread.table(file, header = FALSE, sep = \"\", quote = \"\\\"'\",\n           dec = \".\", row.names, col.names,\n           as.is = !stringsAsFactors,\n           na.strings = \"NA\", colClasses = NA, nrows = -1,\n           skip = 0, check.names = TRUE,\n           fill = !blank.lines.skip,\n           strip.white = FALSE, blank.lines.skip = TRUE,\n           comment.char = \"#\",\n           allowEscapes = FALSE, flush = FALSE,\n           stringsAsFactors = default.stringsAsFactors(),\n           fileEncoding = \"\", encoding = \"unknown\", text,\n           skipNul = FALSE)\nAs I mention in the foregoing chapter, the mandatory input for read.table() and friends is file which is the name of the file which the data are to be read from. On the more technical side, recall that there is a connection() function used by R related to the file argument.\nThe following table lists some read.table() arguments and their meaning:\n\n\n\nArgument\nDescription\n\n\n\n\nfile\nName of file\n\n\nheader\nWhether column names are in 1st line\n\n\nsep\nCharacter used as field separator\n\n\nquote\nQuoting characters\n\n\ndec\nCharacter for decimal point\n\n\nrow.names\nOptional vector of row names\n\n\ncol.names\nOptional vector of column names\n\n\nna.strings\nCharacters treated as missing values\n\n\ncolClasses\nOptional vector of data types for columns\n\n\nnrows\nMaximum number of rows to read in\n\n\nskip\nNumber of lines to skip before reading data\n\n\ncheck.names\nCheck valid column names\n\n\nstringsAsFactors\nShould characters be converted to factors\n\n\n\nIn versions of R < 4.0.0, read.table() and friends convert character strings into factors by default.\nIn addition to read.table(), there’s a handful of sibling functions to read other types of text files (see table below). By the way, all these functions are actually wrappers of read.table():\n\n\n\nFunction\nDescription\n\n\n\n\nread.csv()\nimport comma separated values\n\n\nread.csv2()\nimport semicolon separated values (Europe)\n\n\nread.delim()\nimport tab separated values\n\n\nread.delim2()\nimport tab separated values (Europe)\n\n\n\n\n\n17.3.2 Reading space-separated files\nLet’s review some examples that illustrate the use of the read-table functions. For simplicity’s sake, we’ll assume that all data files are located in your working directory.\nSuppose you have the following data in a file: accounts.txt\naccount bank rate balance\nsavings bricknmor 0.020 1000\nmonmarket online 0.025 2000\ncertificate bricknmor 0.030 3000\nbrokerage online 0.070 5000\nretirement online 0.050 9000\nExample 1. Importing table in blank separated file\n\n# using read.table()\ndat <- read.table(\n  file = \"accounts.txt\", \n  header = TRUE)\n\nThe imported data frame dat will be:\n\n\n       account       bank   rate  balance\n1      savings  bricknmor  0.020     1000\n2    monmarket     online  0.025     2000\n3  certificate  bricknmor  0.030     3000\n4    brokerage     online  0.070     5000\n5   retirement     online  0.050     9000\n\n\nExample 2. Limit the number of rows to read in (first 2 rows):\n\ndat <- read.table(\n  file = \"accounts.txt\", \n  header = TRUE,\n  nrows = 2)\n\nThe imported data frame dat will be:\n\n\n     account       bank   rate  balance\n1    savings  bricknmor  0.020     1000\n2  monmarket     online  0.025     2000\n\n\nExample 3. Skip the first row (no header) and limit the number of rows to read in (4 rows)\n\ndat <- read.table(\n  file = \"accounts.txt\", \n  header = FALSE,\n  skip = 1,\n  nrows = 4)\n\nThe imported data frame dat will be:\n\n\n            V1         V2     V3    V4\n1      savings  bricknmor  0.020  1000\n2    monmarket     online  0.025  2000\n3  certificate  bricknmor  0.030  3000\n4    brokerage     online  0.070  5000\n\n\nExample 4. Skip importing the second and third columns\n\ndat <- read.table(\n  file = \"accounts.txt\", \n  header = TRUE, \n  colClasses = c(\n    \"character\",\n    \"NULL\",\n    \"NULL\",\n    \"numeric\"))\n\nThe imported data frame dat will be:\n\n\n       account  balance\n1      savings     1000\n2    monmarket     2000\n3  certificate     3000\n4    brokerage     5000\n5   retirement     9000\n\n\n\n\n17.3.3 Reading comma-separated files with read.csv()\nLet’s now consider a data table stored in a CSV file: accounts.csv\naccount,bank,rate,balance\nsavings,bricknmor,0.020,1000\nmonmarket,online,0.025,2000\ncertificate,bricknmor,0.030,3000\nbrokerage,online,0.070,5000\nretirement,online,0.050,9000\nExample 1. Data in comma separated value (CSV) file\nWe can use read.table()\n\n# using read.table()\ndat <- read.table(\n  file = \"accounts.csv\",\n  header = TRUE,\n  sep = \",\")\n\nOr more conveniently, we can use read.csv()\n\n# using read.csv()\ndat <- read.csv(file = \"accounts.csv\")\n\nThe imported data frame dat will be:\n\n\n       account       bank   rate  balance\n1      savings  bricknmor  0.020     1000\n2    monmarket     online  0.025     2000\n3  certificate  bricknmor  0.030     3000\n4    brokerage     online  0.070     5000\n5   retirement     online  0.050     9000"
  },
  {
    "objectID": "6-02-import-tables.html#importing-with-scan",
    "href": "6-02-import-tables.html#importing-with-scan",
    "title": "17  Importing Data Tables",
    "section": "17.4 Importing with scan()",
    "text": "17.4 Importing with scan()\nTo finish this chapter, I want to briefly talk to you about the scan() function. This is another function that you can use to read data into a vector or list from the console or from a file. As a matter of fact, scan() is under the hood of read.table() and friends. Because of this, I often refer to scan() as a low-level function.\nLet’s see an example for how to use scan() with a space delimited file. Suppose that we have the data in the file accounts.txt, located in our working directory.\naccount bank rate balance\nsavings bricknmor 0.020 1000\nmonmarket online 0.025 2000\ncertificate bricknmor 0.030 3000\nbrokerage online 0.070 5000\nretirement online 0.050 9000\n\n\n\nscan() is what I call a “low-level function”. What I mean by that is that we typically need to write more code when using this kind of functions. To be more precise, we usually have to specify more arguments when calling scan() than when calling other high-level functions like read.table() and friends.\nLike all other data-import functions, the first argument of scan() is the the name of the file (i.e. file path) to be imported. The second argument is called what, and this has to do with the type of data to be read.\nIf you look at the content of accounts.txt, the first line contains the column names: account bank rate balance. Because the data in this first line is to be used as names, their data-type is \"character\".\nThe rest of the lines have to do with the actual data of the accounts. Each line contains four pieces of data:\n\nthe kind of account, to be encoded as \"character\"\nthe kind of bank, to be encoded also as \"character\"\nthe rate of return, to be encoded as \"double\" (or \"numeric\")\nthe balance amount, to be encoded as \"integer\" or if you prefer as \"double\" (or generically as \"numeric\")\n\nIn order to import the accounts.txt data into R, we must use a two-step process:\n\nfirst we import the column names into a character vector\nthen we import the rest of the lines into a list\n\nHere is how to do it:\n\n# step 1) scan column names\n# ins a character vector\nheader = scan(\n  file = \"accounts.txt\", \n  what = list(\"\", \"\", \"\", \"\"), \n  nmax = 1)\n\nheader\n\n\n\n[1] \"account\" \"bank\"    \"rate\"    \"balance\"\n\n\n\n# step 2) scan the rest of the lines\n# into a list\ndat_list = scan(\n  file = \"accounts.txt\", \n  what = list(character(), character(), double(), integer()),\n  skip = 1)\n\ndat_list\n\n\n\n[[1]]\n[1] \"savings\"     \"monmarket\"   \"certificate\" \"brokerage\"   \"retirement\" \n\n[[2]]\n[1] \"bricknmor\" \"online\"    \"bricknmor\" \"online\"    \"online\"   \n\n[[3]]\n[1] 0.020 0.025 0.030 0.070 0.050\n\n[[4]]\n[1] 1000 2000 3000 5000 9000\n\n\nOnce we have the vector of column names header and the list with the data for each of the columns, we can then assemble the data into a data table using the as.data.frame() function as follows:\n\ndat = as.data.frame(dat_list, col.names = header)\ndat\n\n\n\n      account      bank  rate balance\n1     savings bricknmor 0.020    1000\n2   monmarket    online 0.025    2000\n3 certificate bricknmor 0.030    3000\n4   brokerage    online 0.070    5000\n5  retirement    online 0.050    9000"
  },
  {
    "objectID": "6-02-import-tables.html#in-summary",
    "href": "6-02-import-tables.html#in-summary",
    "title": "17  Importing Data Tables",
    "section": "17.5 In Summary",
    "text": "17.5 In Summary\nWhen importing a data table, you should keep in mind the following considerations.\nWhat is the field separator?\n\nspace \" \"\ntab \"\\t\"\ncomma \",\"\nsemicolon \";\"\nother?\n\nDoes the data file contains:\n\nrow names?\ncolumn names?\nmissing values?\nspecial characters?\n\nSo far …\n\nThere are multiple ways to import data tables\nThe workhorse function is read.table()\nBut you can use the other wrappers, e.g. read.csv()\nThe output is a \"data.frame\" object"
  },
  {
    "objectID": "6-03-exporting-data.html",
    "href": "6-03-exporting-data.html",
    "title": "18  Exporting Data",
    "section": "",
    "text": "One common task in most data analysis projects involves exporting data to external files."
  },
  {
    "objectID": "6-03-exporting-data.html#exporting-tables",
    "href": "6-03-exporting-data.html#exporting-tables",
    "title": "18  Exporting Data",
    "section": "18.1 Exporting Tables",
    "text": "18.1 Exporting Tables\nOne common task in most data analysis projects involves exporting derived data tables (e.g. clean data sets, or processed tables). To accomplish this task you can use any of the write-table functions such as write.table(), write.csv(), etc.\n\n# blank separated (default)\nwrite.table(mtcars, file = 'mtcars.txt', row.names = FALSE)\n\n# tab-separated value\nwrite.table(mtcars, file = 'mtcars.tsv', sep = \"\\t\", row.names = FALSE)\n\n# comma-separated value\nwrite.csv(mtcars, file = 'mtcars.csv', row.names = FALSE)"
  },
  {
    "objectID": "6-03-exporting-data.html#exporting-text",
    "href": "6-03-exporting-data.html#exporting-text",
    "title": "18  Exporting Data",
    "section": "18.2 Exporting Text",
    "text": "18.2 Exporting Text\nAnother type of data-exporting operation has to do with “unstructured” text, and text output in general. By “unstructured” I mean non-tabular data.\nConsider the following piece of code, which writes the elements of a character vector some_text, one element per line (via a file connection) to the file mytext.txt in the local working directory:\n\n# create a connection to a file\n# (assuming output file in working directory)\ntxt <- file(\"mytext.txt\")\n\n# write contents to the file \nwriteLines(text = some_text, con = txt)\n\nNote: Calling file() just creates the connection object but it does not open it. The function writeLines() is the one that opens the connection, writes the content to the file mytext.txt, and then closes the connection on exiting.\nThe previous code can be compactly written with one command without the need to explicitly use the connection function file() as follows:\n\n# write contents to the file \nwriteLines(text = some_text, con = \"mytext.txt\")"
  },
  {
    "objectID": "6-03-exporting-data.html#sending-output-with-cat",
    "href": "6-03-exporting-data.html#sending-output-with-cat",
    "title": "18  Exporting Data",
    "section": "18.3 Sending output with cat()",
    "text": "18.3 Sending output with cat()\nYou can use cat() to concatenate and print information to a file. For instance, say you are interested in some descriptive statistics about the column mpg (miles per gallon) from the mtcars data frame:\n\n# summary statistics of mpg\nmin(mtcars$mpg)\nmax(mtcars$mpg)\nmedian(mtcars$mpg)\nmean(mtcars$mpg)\nsd(mtcars$mpg)\n\nSuppose the goal is to generate a file mpg-statistics.txt with the following contents:\nMiles per Gallon Statistics\n\nMinimum: 10.4 \nMaximum: 33.9 \nMedian : 19.2 \nMean   : 20.09062 \nStd Dev: 6.026948\nHow can this goal be achieved? We can create objects for all the summary statistics, and then involke cat() as many times as there are lines of text to be exported in the output file.\n\n# summary statistics of mpg\nmpg_min <- min(mtcars$mpg)\nmpg_max <- max(mtcars$mpg)\nmpg_med <- median(mtcars$mpg)\nmpg_avg <- mean(mtcars$mpg)\nmpg_sd <- sd(mtcars$mpg)\n\n# name of output file\noutfile <- \"mpg-statistics.txt\"\n\n# first line of the file\ncat(\"Miles per Gallon Statistics\\n\\n\", file = outfile)\n# subsequent lines appended to the output file\ncat(\"Minimum:\", mpg_min, \"\\n\", file = outfile, append = TRUE)\ncat(\"Maximum:\", mpg_max, \"\\n\", file = outfile, append = TRUE)\ncat(\"Median :\", mpg_med, \"\\n\", file = outfile, append = TRUE)\ncat(\"Mean   :\", mpg_avg, \"\\n\", file = outfile, append = TRUE)\ncat(\"Std Dev:\", mpg_sd, \"\\n\", file = outfile, append = TRUE)\n\nNotice that the first call to cat() exports the text that is supposed to be in the first line of content in the output file outfile. The subsequent calls to cat() use the argument append = TRUE so that the next lines of content are appended to the existing outfile. If we don’t use append = TRUE, R will override the existing contents in outfile.\n\n18.3.1 Sending output with cat()\nTo make the content in \"mpg-statistics.txt\" look “prettier”, limiting the number of decimals digits to just 2, you may consider using sprintf(). This function allows you to print strings using C-style formatting.\n\ncat(\"Miles per Gallon Statistics\\n\\n\", file = outfile)\ncat(sprintf(\"Minimum: %0.2f\", mpg_min), \"\\n\", file = outfile, append = TRUE)\ncat(sprintf(\"Maximum: %0.2f\", mpg_max), \"\\n\", file = outfile, append = TRUE)\ncat(sprintf(\"Median : %0.2f\", mpg_med), \"\\n\", file = outfile, append = TRUE)\ncat(sprintf(\"Mean   : %0.2f\", mpg_avg), \"\\n\", file = outfile, append = TRUE)\ncat(sprintf(\"Std Dev: %0.2f\", mpg_sd), \"\\n\", file = outfile, append = TRUE)\n\nLook at the call of sprintf() in the second line: the one that prints the minimum value of miles-per-gallon:\nsprintf(\"Minimum: %0.2f\", mpg_min)\nWhat does sprintf() do in this example? It takes the string \"Minimum: %0.2f\" and the numeric value mpg_min. Observe that the provided string contains some weird-looking characters: %0.2f. This set of characters have a meaning and they are used as a place holder to be replaced with the formatted value mpg_min. Specifically, the notation %0.2f indicates two decimal digits of a double precision value. In other words, a numeric value 10.4 will be printed using two decimal digits as: 10.40. Likewise, a number such as 20.09062 will be printed as 20.09. If you are curious about the various types of C-style string formatting place-holders, check the documentation of sprintf()\nhelp(sprintf)"
  },
  {
    "objectID": "6-03-exporting-data.html#redirecting-output-with-sink",
    "href": "6-03-exporting-data.html#redirecting-output-with-sink",
    "title": "18  Exporting Data",
    "section": "18.4 Redirecting output with sink()",
    "text": "18.4 Redirecting output with sink()\nAnother interesting function is sink(). This function is very useful when you want to export R output as it is displayed in R’s console.\nFor example, consider the following output from summary() applied on three columns of mtcars\n\nsummary(mtcars[ ,c('mpg', 'hp', 'cyl')])\n\n      mpg              hp             cyl       \n Min.   :10.40   Min.   : 52.0   Min.   :4.000  \n 1st Qu.:15.43   1st Qu.: 96.5   1st Qu.:4.000  \n Median :19.20   Median :123.0   Median :6.000  \n Mean   :20.09   Mean   :146.7   Mean   :6.188  \n 3rd Qu.:22.80   3rd Qu.:180.0   3rd Qu.:8.000  \n Max.   :33.90   Max.   :335.0   Max.   :8.000  \n\n\nTo be able to keep the same output displayed by R, you must use sink(). This function will divert R output to the specified file.\n\n# sink output\nsink(file = \"mtcars-stats.txt\")\n\n# summary statistics\nsummary(mtcars[ ,c('mpg', 'hp', 'cyl')])\n\n# stops diverting output\nsink()\n\nThe use of sink() is a bit different from other data-exporting functions. As you can tell from this example, we start by invoking sink() and specifying the name of the output file. Then we include the commands whose outputs will be redirected to the target file. In order to stop the redirecting mechanism, we need to invoke sink() again, without specifying any arguments.\nConsider one more example involving the use of sink() to send the output from running a linear regression of mpg on hp with the function lm(). To make things more interesting, we will also export the results returned by summary() on the regression object. And not only that; we will also run a t-test between am and hp with t.test(), and export the results of such test.\n\n# sink output\nsink(file = \"regression-output.txt\")\n\n# regression of mpg onto hp\nreg = lm(mpg ~ hp, data = mtcars)\nsummary(reg)\n\n# t-test\nt.test(hp ~ am, data = mtcars)\n\n# stop sinking process\nsink()"
  },
  {
    "objectID": "6-03-exporting-data.html#exporting-rs-binary-data",
    "href": "6-03-exporting-data.html#exporting-rs-binary-data",
    "title": "18  Exporting Data",
    "section": "18.5 Exporting R’s Binary Data",
    "text": "18.5 Exporting R’s Binary Data\nR also allows you to save objects in R’s binary format with the functions save() and save.image(). It is customary to use the RData extension for the files created by save() and save.image(). You may also find users specifying the old extension .rda or some other variation.\nYou can use save() to save specific objects from your current session. For example, here is how to save the data frame mtcars3\n\nmtcars3 = mtcars[ ,c('mpg', 'hp', 'cyl')]\nsave(mtcars3, file = 'mtcars3.RData')\n\nThe difference between save() and save.image() is that the latter saves all the objects in your current session. This is actually the function that is run behind the scenes every time you quit R and accept to save the so-called workspace image.\nYou can share mtcars3.RData with any other R user, regardless of the operating system that they use. To read in binary R files, use load()."
  },
  {
    "objectID": "6-03-exporting-data.html#exporting-images",
    "href": "6-03-exporting-data.html#exporting-images",
    "title": "18  Exporting Data",
    "section": "18.6 Exporting Images",
    "text": "18.6 Exporting Images\nIn addition to exporting tables and/or a combination of text-numeric output in the form of several objects, another typical data-exporting activity involves saving graphics, and images in general.\nR comes with a handful of functions to export graphics in various formats:\n\n\n\nFunction\nDescription\n\n\n\n\npng()\nPortable Network Graphics\n\n\njpeg()\nJoint Photographic Experts Group\n\n\npdf()\nPortable Document Format\n\n\nbmp()\nBitmap\n\n\ntiff()\nTag Image File Format\n\n\nsvg()\nScalable Vector Graphics\n\n\n\nFor example, say you have a plot like the following one:\n\nx = 2*pi * seq(from = -1, to = 1, by = 0.01)\nsin_x = sin(x)\ncos_x = cos(x)\n\nplot(x, sin_x, type = \"n\", las = 1, ylab = \"y\")\nabline(h = 0, col = \"gray50\")\nlines(x, sin_x, lwd = 3, col = \"#5A73EB\")\nlines(x, cos_x, lwd = 3, col = \"#eb5a73\")\n\n\n\n\n\n\n\n\nTo export the graphic into a PNG image file, we use png() and dev.off()\n\npng(file = \"myplot.png\", bg = \"transparent\")\nplot(x, sin_x, type = \"n\", las = 1, ylab = \"y\")\nabline(h = 0, col = \"gray50\")\nlines(x, sin_x, lwd = 3, col = \"#5A73EB\")\nlines(x, cos_x, lwd = 3, col = \"#eb5a73\")\ndev.off()\n\nThe usage of png() and friends is similar to sink(). By default, when you use any of the graphing functions such as e.g. plot(), barplot(), boxplot(), etc, the image is rendered in the graphics device that comes in R (or RStudio). By using png(), the rendering mechanism is diverted into an external file. This is why we need to use the function dev.off() to shut down the device used when we are done exporting an image to an external file."
  }
]